---
title: "Tree Data - Hierarchy"
enterprise: true
---
Configure the grid to display structured data by providing data paths.

## Providing Hierarchy

A hierarchy must be presented to the grid as an array of strings, the `getDataPath` callback is used to convert the underlying data to a string array for the grid.

The below structure demonstrates a simple hierarchy, whereby the grid would expect the `getDataPath` callback to return the `path` field:
```
const data = [
    { path: ['A'], id: 'A' },
    { path: ['A', 'B'], id: 'B' },
    { path: ['A', 'B', 'C'], id: 'C' },
]
```
In the above hierarchy, the 'A' row is the parent of 'B', and 'B' is the parent of 'C'.

## Filler Groups

When providing tree data, the grid will create `Filler Groups` for any omitted levels in the hierarchy.
This means a partial hierarchy can be provided and the grid will use the provided row where possible, or create a `Filler Group` where not.

{% gridExampleRunner title="Filler Groups" name="filler-nodes" exampleHeight=305 /%}

The above example demonstrates two group rows which were omitted from the hierarchy, it highlights these by displaying 'Filler' in the 'Group Type' column.
All of the other rows were provided, enabling the grid to use the provided data.

The example above uses the following dataset to provide data for the `D` and `E` group rows, but not the `A` and `B` group rows:
```{% frameworkTransform=true %}
const gridOptions = {
    rowData: [
        { path: ['A', 'B', 'C'], id: 'C' },

        { path: ['D'], id: 'D' },
        { path: ['D', 'E'], id: 'E' },
        { path: ['D', 'E', 'F'], id: 'F' },
    ]
};
```

{% note %}
As `Filler Groups` are generated by the grid, they will not contain a `data` property on the `RowNode`.

They also do not keep their state should the filler group be moved. E.g when changing row path from `A->B->C`, to `D->B->C` group `B` will not keep its selection or expansion states.
{% /note %}

## Duplicate Path Values

The hierarchy from `getDataPath` is treated as an array of unique keys. If the hierarchy contains duplicate values, the grid will not be able to distinguish between them.
Where it is not possible to ensure uniqueness in the displayed hierarchy, providing unique paths and overriding the displayed value is recommended.
This can be done by providing a `field` or `valueGetter` in the `autoGroupColumnDef` grid option.

{% gridExampleRunner title="Duplicate Paths" name="duplicate-paths" exampleHeight=250 /%}

The above example uses the following configuration to show two 'Bob Stevens' working within the same team, where the path is comprised of unique employee IDs:
```{% frameworkTransform=true %}
const gridOptions = {
    treeData: true,
    rowData: [
        { employeeId: '1', name: 'Alice Johnson', path: ['1'] },
        { employeeId: '2', name: 'Bob Stevens', path: ['1', '2'] },
        { employeeId: '3', name: 'Bob Stevens', path: ['1', '3'] },
        { employeeId: '4', name: 'Jessica Adams', path: ['1', '4'] },
    ],
    getDataPath: data => data.path,
    autoGroupColumnDef: {
        field: 'name', // display the name instead of the path key
    },
}
```

## Supplied vs Aggregated

When using Tree Data, columns defined with an aggregation function will always perform aggregations on the group nodes. This means any supplied group data will be ignored in favour of the aggregated values.

{% gridExampleRunner title="Aggregated Data" name="aggregated-data" exampleHeight=350 /%}

The example above uses the configuration below to demonstrate the `Desktop` row is being aggregated to show
the sum of its children (4), rather than the provided value (1), despite both columns showing the same field:
```
const gridOptions = {
    treeData: true,
    columnDefs: [
        {
            headerName: 'Aggregated (Sum)',
            aggFunc: 'sum',
            field: 'items',
        },
        {
            headerName: 'Provided',
            field: 'items',
        },
    ],
};
```

Refer to the [Aggregation](./aggregation/) page for more details.
