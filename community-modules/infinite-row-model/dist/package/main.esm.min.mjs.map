{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\nvar __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);\n\n// community-modules/infinite-row-model/src/infiniteRowModelModule.ts\nimport { ModuleNames } from \"@ag-grid-community/core\";\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteRowModel.ts\nimport {\n  _ as _3,\n  Autowired as Autowired3,\n  Bean,\n  BeanStub as BeanStub2,\n  Events as Events2,\n  NumberSequence as NumberSequence3,\n  PostConstruct as PostConstruct2,\n  PreDestroy as PreDestroy3\n} from \"@ag-grid-community/core\";\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteCache.ts\nimport {\n  Autowired as Autowired2,\n  BeanStub,\n  Events,\n  NumberSequence as NumberSequence2,\n  PreDestroy as PreDestroy2,\n  Qualifier,\n  _ as _2\n} from \"@ag-grid-community/core\";\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteBlock.ts\nimport {\n  _,\n  PostConstruct,\n  PreDestroy,\n  RowNode,\n  RowNodeBlock,\n  Autowired\n} from \"@ag-grid-community/core\";\nvar InfiniteBlock = class extends RowNodeBlock {\n  constructor(id, parentCache, params) {\n    super(id);\n    this.parentCache = parentCache;\n    this.params = params;\n    this.startRow = id * params.blockSize;\n    this.endRow = this.startRow + params.blockSize;\n  }\n  postConstruct() {\n    this.createRowNodes();\n  }\n  getBlockStateJson() {\n    return {\n      id: \"\" + this.getId(),\n      state: {\n        blockNumber: this.getId(),\n        startRow: this.getStartRow(),\n        endRow: this.getEndRow(),\n        pageStatus: this.getState()\n      }\n    };\n  }\n  setDataAndId(rowNode, data, index) {\n    if (_.exists(data)) {\n      rowNode.setDataAndId(data, index.toString());\n    } else {\n      rowNode.setDataAndId(void 0, void 0);\n    }\n  }\n  loadFromDatasource() {\n    const params = this.createLoadParams();\n    if (_.missing(this.params.datasource.getRows)) {\n      console.warn(`AG Grid: datasource is missing getRows method`);\n      return;\n    }\n    window.setTimeout(() => {\n      this.params.datasource.getRows(params);\n    }, 0);\n  }\n  processServerFail() {\n  }\n  createLoadParams() {\n    const params = {\n      startRow: this.getStartRow(),\n      endRow: this.getEndRow(),\n      successCallback: this.pageLoaded.bind(this, this.getVersion()),\n      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),\n      sortModel: this.params.sortModel,\n      filterModel: this.params.filterModel,\n      context: this.gos.getGridCommonParams().context\n    };\n    return params;\n  }\n  forEachNode(callback, sequence, rowCount) {\n    this.rowNodes.forEach((rowNode, index) => {\n      const rowIndex = this.startRow + index;\n      if (rowIndex < rowCount) {\n        callback(rowNode, sequence.next());\n      }\n    });\n  }\n  getLastAccessed() {\n    return this.lastAccessed;\n  }\n  getRow(rowIndex, dontTouchLastAccessed = false) {\n    if (!dontTouchLastAccessed) {\n      this.lastAccessed = this.params.lastAccessedSequence.next();\n    }\n    const localIndex = rowIndex - this.startRow;\n    return this.rowNodes[localIndex];\n  }\n  getStartRow() {\n    return this.startRow;\n  }\n  getEndRow() {\n    return this.endRow;\n  }\n  // creates empty row nodes, data is missing as not loaded yet\n  createRowNodes() {\n    this.rowNodes = [];\n    for (let i = 0; i < this.params.blockSize; i++) {\n      const rowIndex = this.startRow + i;\n      const rowNode = new RowNode(this.beans);\n      rowNode.setRowHeight(this.params.rowHeight);\n      rowNode.uiLevel = 0;\n      rowNode.setRowIndex(rowIndex);\n      rowNode.setRowTop(this.params.rowHeight * rowIndex);\n      this.rowNodes.push(rowNode);\n    }\n  }\n  processServerResult(params) {\n    this.rowNodes.forEach((rowNode, index) => {\n      const data = params.rowData ? params.rowData[index] : void 0;\n      if (!rowNode.id && rowNode.alreadyRendered && data) {\n        this.rowNodes[index] = new RowNode(this.beans);\n        this.rowNodes[index].setRowIndex(rowNode.rowIndex);\n        this.rowNodes[index].setRowTop(rowNode.rowTop);\n        this.rowNodes[index].setRowHeight(rowNode.rowHeight);\n        rowNode.clearRowTopAndRowIndex();\n      }\n      this.setDataAndId(this.rowNodes[index], data, this.startRow + index);\n    });\n    const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : void 0;\n    this.parentCache.pageLoaded(this, finalRowCount);\n  }\n  destroyRowNodes() {\n    this.rowNodes.forEach((rowNode) => {\n      rowNode.clearRowTopAndRowIndex();\n    });\n  }\n};\n__decorateClass([\n  Autowired(\"beans\")\n], InfiniteBlock.prototype, \"beans\", 2);\n__decorateClass([\n  PostConstruct\n], InfiniteBlock.prototype, \"postConstruct\", 1);\n__decorateClass([\n  PreDestroy\n], InfiniteBlock.prototype, \"destroyRowNodes\", 1);\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteCache.ts\nvar _InfiniteCache = class _InfiniteCache extends BeanStub {\n  constructor(params) {\n    super();\n    this.lastRowIndexKnown = false;\n    this.blocks = {};\n    this.blockCount = 0;\n    this.rowCount = params.initialRowCount;\n    this.params = params;\n  }\n  setBeans(loggerFactory) {\n    this.logger = loggerFactory.create(\"InfiniteCache\");\n  }\n  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,\n  // it will want new pages in the cache as it asks for rows. only when we are inserting /\n  // removing rows via the api is dontCreatePage set, where we move rows between the pages.\n  getRow(rowIndex, dontCreatePage = false) {\n    const blockId = Math.floor(rowIndex / this.params.blockSize);\n    let block = this.blocks[blockId];\n    if (!block) {\n      if (dontCreatePage) {\n        return void 0;\n      }\n      block = this.createBlock(blockId);\n    }\n    return block.getRow(rowIndex);\n  }\n  createBlock(blockNumber) {\n    const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));\n    this.blocks[newBlock.getId()] = newBlock;\n    this.blockCount++;\n    this.purgeBlocksIfNeeded(newBlock);\n    this.params.rowNodeBlockLoader.addBlock(newBlock);\n    return newBlock;\n  }\n  // we have this on infinite row model only, not server side row model,\n  // because for server side, it would leave the children in inconsistent\n  // state - eg if a node had children, but after the refresh it had data\n  // for a different row, then the children would be with the wrong row node.\n  refreshCache() {\n    const nothingToRefresh = this.blockCount == 0;\n    if (nothingToRefresh) {\n      this.purgeCache();\n      return;\n    }\n    this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());\n    this.params.rowNodeBlockLoader.checkBlockToLoad();\n  }\n  destroyAllBlocks() {\n    this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));\n  }\n  getRowCount() {\n    return this.rowCount;\n  }\n  isLastRowIndexKnown() {\n    return this.lastRowIndexKnown;\n  }\n  // block calls this, when page loaded\n  pageLoaded(block, lastRow) {\n    if (!this.isAlive()) {\n      return;\n    }\n    this.logger.log(`onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);\n    this.checkRowCount(block, lastRow);\n    this.onCacheUpdated();\n  }\n  purgeBlocksIfNeeded(blockToExclude) {\n    const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);\n    const lastAccessedComparator = (a, b) => b.getLastAccessed() - a.getLastAccessed();\n    blocksForPurging.sort(lastAccessedComparator);\n    const maxBlocksProvided = this.params.maxBlocksInCache > 0;\n    const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;\n    const emptyBlocksToKeep = _InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n    blocksForPurging.forEach((block, index) => {\n      const purgeBecauseBlockEmpty = block.getState() === InfiniteBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;\n      const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n        if (this.isBlockCurrentlyDisplayed(block)) {\n          return;\n        }\n        if (this.isBlockFocused(block)) {\n          return;\n        }\n        this.removeBlockFromCache(block);\n      }\n    });\n  }\n  isBlockFocused(block) {\n    const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n    if (!focusedCell) {\n      return false;\n    }\n    if (focusedCell.rowPinned != null) {\n      return false;\n    }\n    const blockIndexStart = block.getStartRow();\n    const blockIndexEnd = block.getEndRow();\n    const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n    return hasFocus;\n  }\n  isBlockCurrentlyDisplayed(block) {\n    const startIndex = block.getStartRow();\n    const endIndex = block.getEndRow() - 1;\n    return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n  }\n  removeBlockFromCache(blockToRemove) {\n    if (!blockToRemove) {\n      return;\n    }\n    this.destroyBlock(blockToRemove);\n  }\n  checkRowCount(block, lastRow) {\n    if (typeof lastRow === \"number\" && lastRow >= 0) {\n      this.rowCount = lastRow;\n      this.lastRowIndexKnown = true;\n    } else if (!this.lastRowIndexKnown) {\n      const lastRowIndex = (block.getId() + 1) * this.params.blockSize;\n      const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;\n      if (this.rowCount < lastRowIndexPlusOverflow) {\n        this.rowCount = lastRowIndexPlusOverflow;\n      }\n    }\n  }\n  setRowCount(rowCount, lastRowIndexKnown) {\n    this.rowCount = rowCount;\n    if (_2.exists(lastRowIndexKnown)) {\n      this.lastRowIndexKnown = lastRowIndexKnown;\n    }\n    if (!this.lastRowIndexKnown) {\n      if (this.rowCount % this.params.blockSize === 0) {\n        this.rowCount++;\n      }\n    }\n    this.onCacheUpdated();\n  }\n  forEachNodeDeep(callback) {\n    const sequence = new NumberSequence2();\n    this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));\n  }\n  getBlocksInOrder() {\n    const blockComparator = (a, b) => a.getId() - b.getId();\n    const blocks = _2.getAllValuesInObject(this.blocks).sort(blockComparator);\n    return blocks;\n  }\n  destroyBlock(block) {\n    delete this.blocks[block.getId()];\n    this.destroyBean(block);\n    this.blockCount--;\n    this.params.rowNodeBlockLoader.removeBlock(block);\n  }\n  // gets called 1) row count changed 2) cache purged 3) items inserted\n  onCacheUpdated() {\n    if (this.isAlive()) {\n      this.destroyAllBlocksPastVirtualRowCount();\n      const event = {\n        type: Events.EVENT_STORE_UPDATED\n      };\n      this.eventService.dispatchEvent(event);\n    }\n  }\n  destroyAllBlocksPastVirtualRowCount() {\n    const blocksToDestroy = [];\n    this.getBlocksInOrder().forEach((block) => {\n      const startRow = block.getId() * this.params.blockSize;\n      if (startRow >= this.rowCount) {\n        blocksToDestroy.push(block);\n      }\n    });\n    if (blocksToDestroy.length > 0) {\n      blocksToDestroy.forEach((block) => this.destroyBlock(block));\n    }\n  }\n  purgeCache() {\n    this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));\n    this.lastRowIndexKnown = false;\n    if (this.rowCount === 0) {\n      this.rowCount = this.params.initialRowCount;\n    }\n    this.onCacheUpdated();\n  }\n  getRowNodesInRange(firstInRange, lastInRange) {\n    const result = [];\n    let lastBlockId = -1;\n    let inActiveRange = false;\n    const numberSequence = new NumberSequence2();\n    if (_2.missing(firstInRange)) {\n      inActiveRange = true;\n    }\n    let foundGapInSelection = false;\n    this.getBlocksInOrder().forEach((block) => {\n      if (foundGapInSelection) {\n        return;\n      }\n      if (inActiveRange && lastBlockId + 1 !== block.getId()) {\n        foundGapInSelection = true;\n        return;\n      }\n      lastBlockId = block.getId();\n      block.forEachNode((rowNode) => {\n        const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n        if (inActiveRange || hitFirstOrLast) {\n          result.push(rowNode);\n        }\n        if (hitFirstOrLast) {\n          inActiveRange = !inActiveRange;\n        }\n      }, numberSequence, this.rowCount);\n    });\n    const invalidRange = foundGapInSelection || inActiveRange;\n    return invalidRange ? [] : result;\n  }\n};\n// this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n// blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n// scrolled over are not needed to be loaded.\n_InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n__decorateClass([\n  Autowired2(\"rowRenderer\")\n], _InfiniteCache.prototype, \"rowRenderer\", 2);\n__decorateClass([\n  Autowired2(\"focusService\")\n], _InfiniteCache.prototype, \"focusService\", 2);\n__decorateClass([\n  __decorateParam(0, Qualifier(\"loggerFactory\"))\n], _InfiniteCache.prototype, \"setBeans\", 1);\n__decorateClass([\n  PreDestroy2\n], _InfiniteCache.prototype, \"destroyAllBlocks\", 1);\nvar InfiniteCache = _InfiniteCache;\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteRowModel.ts\nvar InfiniteRowModel = class extends BeanStub2 {\n  getRowBounds(index) {\n    return {\n      rowHeight: this.rowHeight,\n      rowTop: this.rowHeight * index\n    };\n  }\n  // we don't implement as lazy row heights is not supported in this row model\n  ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    return false;\n  }\n  init() {\n    if (!this.gos.isRowModelType(\"infinite\")) {\n      return;\n    }\n    this.rowHeight = this.gos.getRowHeightAsNumber();\n    this.addEventListeners();\n    this.addDestroyFunc(() => this.destroyCache());\n    this.verifyProps();\n  }\n  verifyProps() {\n    if (this.gos.exists(\"initialGroupOrderComparator\")) {\n      _3.warnOnce(\"initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side\");\n    }\n  }\n  start() {\n    this.setDatasource(this.gos.get(\"datasource\"));\n  }\n  destroyDatasource() {\n    if (this.datasource) {\n      this.getContext().destroyBean(this.datasource);\n      this.rowRenderer.datasourceChanged();\n      this.datasource = null;\n    }\n  }\n  addEventListeners() {\n    this.addManagedListener(this.eventService, Events2.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addManagedListener(this.eventService, Events2.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    this.addManagedListener(this.eventService, Events2.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));\n    this.addManagedListener(this.eventService, Events2.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this));\n    this.addManagedPropertyListener(\"datasource\", () => this.setDatasource(this.gos.get(\"datasource\")));\n    this.addManagedPropertyListener(\"cacheBlockSize\", () => this.resetCache());\n    this.addManagedPropertyListener(\"rowHeight\", () => {\n      this.rowHeight = this.gos.getRowHeightAsNumber();\n      this.cacheParams.rowHeight = this.rowHeight;\n      this.updateRowHeights();\n    });\n  }\n  onFilterChanged() {\n    this.reset();\n  }\n  onSortChanged() {\n    this.reset();\n  }\n  onColumnEverything() {\n    let resetRequired;\n    if (this.cacheParams) {\n      resetRequired = this.isSortModelDifferent();\n    } else {\n      resetRequired = true;\n    }\n    if (resetRequired) {\n      this.reset();\n    }\n  }\n  isSortModelDifferent() {\n    return !_3.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());\n  }\n  getType() {\n    return \"infinite\";\n  }\n  setDatasource(datasource) {\n    this.destroyDatasource();\n    this.datasource = datasource;\n    if (datasource) {\n      this.reset();\n    }\n  }\n  isEmpty() {\n    return !this.infiniteCache;\n  }\n  isRowsToRender() {\n    return !!this.infiniteCache;\n  }\n  getNodesInRangeForSelection(firstInRange, lastInRange) {\n    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];\n  }\n  reset() {\n    if (!this.datasource) {\n      return;\n    }\n    const getRowIdFunc = this.gos.getCallback(\"getRowId\");\n    const userGeneratingIds = getRowIdFunc != null;\n    if (!userGeneratingIds) {\n      this.selectionService.reset(\"rowDataChanged\");\n    }\n    this.resetCache();\n  }\n  createModelUpdatedEvent() {\n    return {\n      type: Events2.EVENT_MODEL_UPDATED,\n      // not sure if these should all be false - noticed if after implementing,\n      // maybe they should be true?\n      newPage: false,\n      newPageSize: false,\n      newData: false,\n      keepRenderedRows: true,\n      animate: false\n    };\n  }\n  resetCache() {\n    this.destroyCache();\n    this.cacheParams = {\n      // the user provided datasource\n      datasource: this.datasource,\n      // sort and filter model\n      filterModel: this.filterManager.getFilterModel(),\n      sortModel: this.sortController.getSortModel(),\n      rowNodeBlockLoader: this.rowNodeBlockLoader,\n      // properties - this way we take a snapshot of them, so if user changes any, they will be\n      // used next time we create a new cache, which is generally after a filter or sort change,\n      // or a new datasource is set\n      initialRowCount: this.gos.get(\"infiniteInitialRowCount\"),\n      maxBlocksInCache: this.gos.get(\"maxBlocksInCache\"),\n      rowHeight: this.gos.getRowHeightAsNumber(),\n      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n      // the current page and request first row of next page\n      overflowSize: this.gos.get(\"cacheOverflowSize\"),\n      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n      // server for one page at a time. so the default if not specified is 100.\n      blockSize: this.gos.get(\"cacheBlockSize\"),\n      // the cache could create this, however it is also used by the pages, so handy to create it\n      // here as the settings are also passed to the pages\n      lastAccessedSequence: new NumberSequence3()\n    };\n    this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));\n    this.eventService.dispatchEventOnce({\n      type: Events2.EVENT_ROW_COUNT_READY\n    });\n    const event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  }\n  updateRowHeights() {\n    this.forEachNode((node) => {\n      node.setRowHeight(this.rowHeight);\n      node.setRowTop(this.rowHeight * node.rowIndex);\n    });\n    const event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  }\n  destroyCache() {\n    if (this.infiniteCache) {\n      this.infiniteCache = this.destroyBean(this.infiniteCache);\n    }\n  }\n  onCacheUpdated() {\n    const event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  }\n  getRow(rowIndex) {\n    if (!this.infiniteCache) {\n      return void 0;\n    }\n    if (rowIndex >= this.infiniteCache.getRowCount()) {\n      return void 0;\n    }\n    return this.infiniteCache.getRow(rowIndex);\n  }\n  getRowNode(id) {\n    let result;\n    this.forEachNode((rowNode) => {\n      if (rowNode.id === id) {\n        result = rowNode;\n      }\n    });\n    return result;\n  }\n  forEachNode(callback) {\n    if (this.infiniteCache) {\n      this.infiniteCache.forEachNodeDeep(callback);\n    }\n  }\n  getTopLevelRowCount() {\n    return this.getRowCount();\n  }\n  getTopLevelRowDisplayedIndex(topLevelIndex) {\n    return topLevelIndex;\n  }\n  getRowIndexAtPixel(pixel) {\n    if (this.rowHeight !== 0) {\n      const rowIndexForPixel = Math.floor(pixel / this.rowHeight);\n      const lastRowIndex = this.getRowCount() - 1;\n      if (rowIndexForPixel > lastRowIndex) {\n        return lastRowIndex;\n      }\n      return rowIndexForPixel;\n    }\n    return 0;\n  }\n  getRowCount() {\n    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;\n  }\n  isRowPresent(rowNode) {\n    const foundRowNode = this.getRowNode(rowNode.id);\n    return !!foundRowNode;\n  }\n  refreshCache() {\n    if (this.infiniteCache) {\n      this.infiniteCache.refreshCache();\n    }\n  }\n  purgeCache() {\n    if (this.infiniteCache) {\n      this.infiniteCache.purgeCache();\n    }\n  }\n  // for iRowModel\n  isLastRowIndexKnown() {\n    if (this.infiniteCache) {\n      return this.infiniteCache.isLastRowIndexKnown();\n    }\n    return false;\n  }\n  setRowCount(rowCount, lastRowIndexKnown) {\n    if (this.infiniteCache) {\n      this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);\n    }\n  }\n};\n__decorateClass([\n  Autowired3(\"filterManager\")\n], InfiniteRowModel.prototype, \"filterManager\", 2);\n__decorateClass([\n  Autowired3(\"sortController\")\n], InfiniteRowModel.prototype, \"sortController\", 2);\n__decorateClass([\n  Autowired3(\"selectionService\")\n], InfiniteRowModel.prototype, \"selectionService\", 2);\n__decorateClass([\n  Autowired3(\"rowRenderer\")\n], InfiniteRowModel.prototype, \"rowRenderer\", 2);\n__decorateClass([\n  Autowired3(\"rowNodeBlockLoader\")\n], InfiniteRowModel.prototype, \"rowNodeBlockLoader\", 2);\n__decorateClass([\n  PostConstruct2\n], InfiniteRowModel.prototype, \"init\", 1);\n__decorateClass([\n  PreDestroy3\n], InfiniteRowModel.prototype, \"destroyDatasource\", 1);\nInfiniteRowModel = __decorateClass([\n  Bean(\"rowModel\")\n], InfiniteRowModel);\n\n// community-modules/infinite-row-model/src/version.ts\nvar VERSION = \"31.3.2\";\n\n// community-modules/infinite-row-model/src/infiniteRowModelModule.ts\nvar InfiniteRowModelModule = {\n  version: VERSION,\n  moduleName: ModuleNames.InfiniteRowModelModule,\n  rowModel: \"infinite\",\n  beans: [InfiniteRowModel]\n};\nexport {\n  InfiniteRowModelModule\n};\n"],
  "mappings": "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",
  "names": ["__defProp", "__getOwnPropDesc", "__decorateClass", "decorators", "target", "key", "kind", "result", "i", "decorator", "__decorateParam", "index", "ModuleNames", "_3", "Autowired3", "Bean", "BeanStub2", "Events2", "NumberSequence3", "PostConstruct2", "PreDestroy3", "Autowired2", "BeanStub", "Events", "NumberSequence2", "PreDestroy2", "Qualifier", "_2", "_", "PostConstruct", "PreDestroy", "RowNode", "RowNodeBlock", "Autowired", "InfiniteBlock", "id", "parentCache", "params", "rowNode", "data", "callback", "sequence", "rowCount", "rowIndex", "dontTouchLastAccessed", "localIndex", "finalRowCount", "_InfiniteCache", "loggerFactory", "dontCreatePage", "blockId", "block", "blockNumber", "newBlock", "lastRow", "blockToExclude", "blocksForPurging", "b", "lastAccessedComparator", "maxBlocksProvided", "blocksToKeep", "emptyBlocksToKeep", "purgeBecauseBlockEmpty", "purgeBecauseCacheFull", "focusedCell", "blockIndexStart", "blockIndexEnd", "startIndex", "endIndex", "blockToRemove", "lastRowIndexPlusOverflow", "lastRowIndexKnown", "blockComparator", "a", "event", "blocksToDestroy", "firstInRange", "lastInRange", "lastBlockId", "inActiveRange", "numberSequence", "foundGapInSelection", "hitFirstOrLast", "InfiniteCache", "InfiniteRowModel", "startPixel", "endPixel", "startLimitIndex", "endLimitIndex", "resetRequired", "datasource", "node", "topLevelIndex", "pixel", "rowIndexForPixel", "lastRowIndex", "VERSION", "InfiniteRowModelModule"]
}
