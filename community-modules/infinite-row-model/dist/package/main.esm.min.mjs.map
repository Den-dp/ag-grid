{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["// community-modules/infinite-row-model/src/infiniteRowModelModule.ts\nimport {\n  ModuleNames,\n  RowModelHelperService,\n  _RowNodeBlockModule,\n  _SsrmInfiniteSharedApiModule\n} from \"@ag-grid-community/core\";\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteRowModel.ts\nimport { BeanStub as BeanStub2, NumberSequence as NumberSequence2, _jsonEquals, _warnOnce as _warnOnce2 } from \"@ag-grid-community/core\";\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteCache.ts\nimport { BeanStub, NumberSequence, _exists as _exists2, _getAllValuesInObject, _log } from \"@ag-grid-community/core\";\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteBlock.ts\nimport { RowNode, RowNodeBlock, _exists, _missing, _warnOnce } from \"@ag-grid-community/core\";\nvar InfiniteBlock = class extends RowNodeBlock {\n  wireBeans(beans) {\n    this.beans = beans;\n  }\n  constructor(id, parentCache, params) {\n    super(id);\n    this.parentCache = parentCache;\n    this.params = params;\n    this.startRow = id * params.blockSize;\n    this.endRow = this.startRow + params.blockSize;\n  }\n  postConstruct() {\n    this.createRowNodes();\n  }\n  getBlockStateJson() {\n    return {\n      id: \"\" + this.getId(),\n      state: {\n        blockNumber: this.getId(),\n        startRow: this.getStartRow(),\n        endRow: this.getEndRow(),\n        pageStatus: this.getState()\n      }\n    };\n  }\n  setDataAndId(rowNode, data, index) {\n    if (_exists(data)) {\n      rowNode.setDataAndId(data, index.toString());\n    } else {\n      rowNode.setDataAndId(void 0, void 0);\n    }\n  }\n  loadFromDatasource() {\n    const params = this.createLoadParams();\n    if (_missing(this.params.datasource.getRows)) {\n      _warnOnce(`datasource is missing getRows method`);\n      return;\n    }\n    window.setTimeout(() => {\n      this.params.datasource.getRows(params);\n    }, 0);\n  }\n  processServerFail() {\n  }\n  createLoadParams() {\n    const params = {\n      startRow: this.getStartRow(),\n      endRow: this.getEndRow(),\n      successCallback: this.pageLoaded.bind(this, this.getVersion()),\n      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),\n      sortModel: this.params.sortModel,\n      filterModel: this.params.filterModel,\n      context: this.gos.getGridCommonParams().context\n    };\n    return params;\n  }\n  forEachNode(callback, sequence, rowCount) {\n    this.rowNodes.forEach((rowNode, index) => {\n      const rowIndex = this.startRow + index;\n      if (rowIndex < rowCount) {\n        callback(rowNode, sequence.next());\n      }\n    });\n  }\n  getLastAccessed() {\n    return this.lastAccessed;\n  }\n  getRow(rowIndex, dontTouchLastAccessed = false) {\n    if (!dontTouchLastAccessed) {\n      this.lastAccessed = this.params.lastAccessedSequence.next();\n    }\n    const localIndex = rowIndex - this.startRow;\n    return this.rowNodes[localIndex];\n  }\n  getStartRow() {\n    return this.startRow;\n  }\n  getEndRow() {\n    return this.endRow;\n  }\n  // creates empty row nodes, data is missing as not loaded yet\n  createRowNodes() {\n    this.rowNodes = [];\n    for (let i = 0; i < this.params.blockSize; i++) {\n      const rowIndex = this.startRow + i;\n      const rowNode = new RowNode(this.beans);\n      rowNode.setRowHeight(this.params.rowHeight);\n      rowNode.uiLevel = 0;\n      rowNode.setRowIndex(rowIndex);\n      rowNode.setRowTop(this.params.rowHeight * rowIndex);\n      this.rowNodes.push(rowNode);\n    }\n  }\n  processServerResult(params) {\n    this.rowNodes.forEach((rowNode, index) => {\n      const data = params.rowData ? params.rowData[index] : void 0;\n      if (!rowNode.id && rowNode.alreadyRendered && data) {\n        this.rowNodes[index] = new RowNode(this.beans);\n        this.rowNodes[index].setRowIndex(rowNode.rowIndex);\n        this.rowNodes[index].setRowTop(rowNode.rowTop);\n        this.rowNodes[index].setRowHeight(rowNode.rowHeight);\n        rowNode.clearRowTopAndRowIndex();\n      }\n      this.setDataAndId(this.rowNodes[index], data, this.startRow + index);\n    });\n    const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : void 0;\n    this.parentCache.pageLoaded(this, finalRowCount);\n  }\n  destroy() {\n    this.rowNodes.forEach((rowNode) => {\n      rowNode.clearRowTopAndRowIndex();\n    });\n    super.destroy();\n  }\n};\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteCache.ts\nvar MAX_EMPTY_BLOCKS_TO_KEEP = 2;\nvar InfiniteCache = class extends BeanStub {\n  constructor(params) {\n    super();\n    this.lastRowIndexKnown = false;\n    this.blocks = {};\n    this.blockCount = 0;\n    this.rowCount = params.initialRowCount;\n    this.params = params;\n  }\n  wireBeans(beans) {\n    this.rowRenderer = beans.rowRenderer;\n    this.focusService = beans.focusService;\n  }\n  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,\n  // it will want new pages in the cache as it asks for rows. only when we are inserting /\n  // removing rows via the api is dontCreatePage set, where we move rows between the pages.\n  getRow(rowIndex, dontCreatePage = false) {\n    const blockId = Math.floor(rowIndex / this.params.blockSize);\n    let block = this.blocks[blockId];\n    if (!block) {\n      if (dontCreatePage) {\n        return void 0;\n      }\n      block = this.createBlock(blockId);\n    }\n    return block.getRow(rowIndex);\n  }\n  createBlock(blockNumber) {\n    const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));\n    this.blocks[newBlock.getId()] = newBlock;\n    this.blockCount++;\n    this.purgeBlocksIfNeeded(newBlock);\n    this.params.rowNodeBlockLoader.addBlock(newBlock);\n    return newBlock;\n  }\n  // we have this on infinite row model only, not server side row model,\n  // because for server side, it would leave the children in inconsistent\n  // state - eg if a node had children, but after the refresh it had data\n  // for a different row, then the children would be with the wrong row node.\n  refreshCache() {\n    const nothingToRefresh = this.blockCount == 0;\n    if (nothingToRefresh) {\n      this.purgeCache();\n      return;\n    }\n    this.getBlocksInOrder().forEach((block) => block.setStateWaitingToLoad());\n    this.params.rowNodeBlockLoader.checkBlockToLoad();\n  }\n  destroy() {\n    this.getBlocksInOrder().forEach((block) => this.destroyBlock(block));\n    super.destroy();\n  }\n  getRowCount() {\n    return this.rowCount;\n  }\n  isLastRowIndexKnown() {\n    return this.lastRowIndexKnown;\n  }\n  // block calls this, when page loaded\n  pageLoaded(block, lastRow) {\n    if (!this.isAlive()) {\n      return;\n    }\n    if (this.gos.get(\"debug\")) {\n      _log(`InfiniteCache - onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);\n    }\n    this.checkRowCount(block, lastRow);\n    this.onCacheUpdated();\n  }\n  purgeBlocksIfNeeded(blockToExclude) {\n    const blocksForPurging = this.getBlocksInOrder().filter((b) => b != blockToExclude);\n    const lastAccessedComparator = (a, b) => b.getLastAccessed() - a.getLastAccessed();\n    blocksForPurging.sort(lastAccessedComparator);\n    const maxBlocksProvided = this.params.maxBlocksInCache > 0;\n    const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;\n    const emptyBlocksToKeep = MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n    blocksForPurging.forEach((block, index) => {\n      const purgeBecauseBlockEmpty = block.getState() === \"needsLoading\" && index >= emptyBlocksToKeep;\n      const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n        if (this.isBlockCurrentlyDisplayed(block)) {\n          return;\n        }\n        if (this.isBlockFocused(block)) {\n          return;\n        }\n        this.removeBlockFromCache(block);\n      }\n    });\n  }\n  isBlockFocused(block) {\n    const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n    if (!focusedCell) {\n      return false;\n    }\n    if (focusedCell.rowPinned != null) {\n      return false;\n    }\n    const blockIndexStart = block.getStartRow();\n    const blockIndexEnd = block.getEndRow();\n    const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n    return hasFocus;\n  }\n  isBlockCurrentlyDisplayed(block) {\n    const startIndex = block.getStartRow();\n    const endIndex = block.getEndRow() - 1;\n    return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n  }\n  removeBlockFromCache(blockToRemove) {\n    if (!blockToRemove) {\n      return;\n    }\n    this.destroyBlock(blockToRemove);\n  }\n  checkRowCount(block, lastRow) {\n    if (typeof lastRow === \"number\" && lastRow >= 0) {\n      this.rowCount = lastRow;\n      this.lastRowIndexKnown = true;\n    } else if (!this.lastRowIndexKnown) {\n      const lastRowIndex = (block.getId() + 1) * this.params.blockSize;\n      const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;\n      if (this.rowCount < lastRowIndexPlusOverflow) {\n        this.rowCount = lastRowIndexPlusOverflow;\n      }\n    }\n  }\n  setRowCount(rowCount, lastRowIndexKnown) {\n    this.rowCount = rowCount;\n    if (_exists2(lastRowIndexKnown)) {\n      this.lastRowIndexKnown = lastRowIndexKnown;\n    }\n    if (!this.lastRowIndexKnown) {\n      if (this.rowCount % this.params.blockSize === 0) {\n        this.rowCount++;\n      }\n    }\n    this.onCacheUpdated();\n  }\n  forEachNodeDeep(callback) {\n    const sequence = new NumberSequence();\n    this.getBlocksInOrder().forEach((block) => block.forEachNode(callback, sequence, this.rowCount));\n  }\n  getBlocksInOrder() {\n    const blockComparator = (a, b) => a.getId() - b.getId();\n    const blocks = _getAllValuesInObject(this.blocks).sort(blockComparator);\n    return blocks;\n  }\n  destroyBlock(block) {\n    delete this.blocks[block.getId()];\n    this.destroyBean(block);\n    this.blockCount--;\n    this.params.rowNodeBlockLoader.removeBlock(block);\n  }\n  // gets called 1) row count changed 2) cache purged 3) items inserted\n  onCacheUpdated() {\n    if (this.isAlive()) {\n      this.destroyAllBlocksPastVirtualRowCount();\n      const event = {\n        type: \"storeUpdated\"\n      };\n      this.eventService.dispatchEvent(event);\n    }\n  }\n  destroyAllBlocksPastVirtualRowCount() {\n    const blocksToDestroy = [];\n    this.getBlocksInOrder().forEach((block) => {\n      const startRow = block.getId() * this.params.blockSize;\n      if (startRow >= this.rowCount) {\n        blocksToDestroy.push(block);\n      }\n    });\n    if (blocksToDestroy.length > 0) {\n      blocksToDestroy.forEach((block) => this.destroyBlock(block));\n    }\n  }\n  purgeCache() {\n    this.getBlocksInOrder().forEach((block) => this.removeBlockFromCache(block));\n    this.lastRowIndexKnown = false;\n    if (this.rowCount === 0) {\n      this.rowCount = this.params.initialRowCount;\n    }\n    this.onCacheUpdated();\n  }\n  getRowNodesInRange(firstInRange, lastInRange) {\n    const result = [];\n    let lastBlockId = -1;\n    let inActiveRange = false;\n    const numberSequence = new NumberSequence();\n    let foundGapInSelection = false;\n    this.getBlocksInOrder().forEach((block) => {\n      if (foundGapInSelection) {\n        return;\n      }\n      if (inActiveRange && lastBlockId + 1 !== block.getId()) {\n        foundGapInSelection = true;\n        return;\n      }\n      lastBlockId = block.getId();\n      block.forEachNode(\n        (rowNode) => {\n          const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n          if (inActiveRange || hitFirstOrLast) {\n            result.push(rowNode);\n          }\n          if (hitFirstOrLast) {\n            inActiveRange = !inActiveRange;\n          }\n        },\n        numberSequence,\n        this.rowCount\n      );\n    });\n    const invalidRange = foundGapInSelection || inActiveRange;\n    return invalidRange ? [] : result;\n  }\n};\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteRowModel.ts\nvar InfiniteRowModel = class extends BeanStub2 {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"rowModel\";\n  }\n  wireBeans(beans) {\n    this.filterManager = beans.filterManager;\n    this.sortController = beans.sortController;\n    this.selectionService = beans.selectionService;\n    this.rowRenderer = beans.rowRenderer;\n    this.rowNodeBlockLoader = beans.rowNodeBlockLoader;\n  }\n  getRowBounds(index) {\n    return {\n      rowHeight: this.rowHeight,\n      rowTop: this.rowHeight * index\n    };\n  }\n  // we don't implement as lazy row heights is not supported in this row model\n  ensureRowHeightsValid() {\n    return false;\n  }\n  postConstruct() {\n    if (!this.gos.isRowModelType(\"infinite\")) {\n      return;\n    }\n    this.rowHeight = this.gos.getRowHeightAsNumber();\n    this.addEventListeners();\n    this.addDestroyFunc(() => this.destroyCache());\n    this.verifyProps();\n  }\n  verifyProps() {\n    if (this.gos.exists(\"initialGroupOrderComparator\")) {\n      _warnOnce2(\n        \"initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side\"\n      );\n    }\n  }\n  start() {\n    this.setDatasource(this.gos.get(\"datasource\"));\n  }\n  destroy() {\n    this.destroyDatasource();\n    super.destroy();\n  }\n  destroyDatasource() {\n    if (this.datasource) {\n      this.destroyBean(this.datasource);\n      this.rowRenderer.datasourceChanged();\n      this.datasource = null;\n    }\n  }\n  addEventListeners() {\n    this.addManagedEventListeners({\n      filterChanged: this.onFilterChanged.bind(this),\n      sortChanged: this.onSortChanged.bind(this),\n      newColumnsLoaded: this.onColumnEverything.bind(this),\n      storeUpdated: this.onCacheUpdated.bind(this)\n    });\n    this.addManagedPropertyListener(\"datasource\", () => this.setDatasource(this.gos.get(\"datasource\")));\n    this.addManagedPropertyListener(\"cacheBlockSize\", () => this.resetCache());\n    this.addManagedPropertyListener(\"rowHeight\", () => {\n      this.rowHeight = this.gos.getRowHeightAsNumber();\n      this.cacheParams.rowHeight = this.rowHeight;\n      this.updateRowHeights();\n    });\n  }\n  onFilterChanged() {\n    this.reset();\n  }\n  onSortChanged() {\n    this.reset();\n  }\n  onColumnEverything() {\n    let resetRequired;\n    if (this.cacheParams) {\n      resetRequired = this.isSortModelDifferent();\n    } else {\n      resetRequired = true;\n    }\n    if (resetRequired) {\n      this.reset();\n    }\n  }\n  isSortModelDifferent() {\n    return !_jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());\n  }\n  getType() {\n    return \"infinite\";\n  }\n  setDatasource(datasource) {\n    this.destroyDatasource();\n    this.datasource = datasource;\n    if (datasource) {\n      this.reset();\n    }\n  }\n  isEmpty() {\n    return !this.infiniteCache;\n  }\n  isRowsToRender() {\n    return !!this.infiniteCache;\n  }\n  getNodesInRangeForSelection(firstInRange, lastInRange) {\n    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];\n  }\n  reset() {\n    if (!this.datasource) {\n      return;\n    }\n    const getRowIdFunc = this.gos.getRowIdCallback();\n    const userGeneratingIds = getRowIdFunc != null;\n    if (!userGeneratingIds) {\n      this.selectionService.reset(\"rowDataChanged\");\n    }\n    this.resetCache();\n  }\n  createModelUpdatedEvent() {\n    return {\n      type: \"modelUpdated\",\n      // not sure if these should all be false - noticed if after implementing,\n      // maybe they should be true?\n      newPage: false,\n      newPageSize: false,\n      newData: false,\n      keepRenderedRows: true,\n      animate: false\n    };\n  }\n  resetCache() {\n    this.destroyCache();\n    this.cacheParams = {\n      // the user provided datasource\n      datasource: this.datasource,\n      // sort and filter model\n      filterModel: this.filterManager?.getFilterModel() ?? {},\n      sortModel: this.sortController.getSortModel(),\n      rowNodeBlockLoader: this.rowNodeBlockLoader,\n      // properties - this way we take a snapshot of them, so if user changes any, they will be\n      // used next time we create a new cache, which is generally after a filter or sort change,\n      // or a new datasource is set\n      initialRowCount: this.gos.get(\"infiniteInitialRowCount\"),\n      maxBlocksInCache: this.gos.get(\"maxBlocksInCache\"),\n      rowHeight: this.gos.getRowHeightAsNumber(),\n      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n      // the current page and request first row of next page\n      overflowSize: this.gos.get(\"cacheOverflowSize\"),\n      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n      // server for one page at a time. so the default if not specified is 100.\n      blockSize: this.gos.get(\"cacheBlockSize\"),\n      // the cache could create this, however it is also used by the pages, so handy to create it\n      // here as the settings are also passed to the pages\n      lastAccessedSequence: new NumberSequence2()\n    };\n    this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));\n    this.eventService.dispatchEventOnce({\n      type: \"rowCountReady\"\n    });\n    const event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  }\n  updateRowHeights() {\n    this.forEachNode((node) => {\n      node.setRowHeight(this.rowHeight);\n      node.setRowTop(this.rowHeight * node.rowIndex);\n    });\n    const event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  }\n  destroyCache() {\n    if (this.infiniteCache) {\n      this.infiniteCache = this.destroyBean(this.infiniteCache);\n    }\n  }\n  onCacheUpdated() {\n    const event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  }\n  getRow(rowIndex) {\n    if (!this.infiniteCache) {\n      return void 0;\n    }\n    if (rowIndex >= this.infiniteCache.getRowCount()) {\n      return void 0;\n    }\n    return this.infiniteCache.getRow(rowIndex);\n  }\n  getRowNode(id) {\n    let result;\n    this.forEachNode((rowNode) => {\n      if (rowNode.id === id) {\n        result = rowNode;\n      }\n    });\n    return result;\n  }\n  forEachNode(callback) {\n    if (this.infiniteCache) {\n      this.infiniteCache.forEachNodeDeep(callback);\n    }\n  }\n  getTopLevelRowCount() {\n    return this.getRowCount();\n  }\n  getTopLevelRowDisplayedIndex(topLevelIndex) {\n    return topLevelIndex;\n  }\n  getRowIndexAtPixel(pixel) {\n    if (this.rowHeight !== 0) {\n      const rowIndexForPixel = Math.floor(pixel / this.rowHeight);\n      const lastRowIndex = this.getRowCount() - 1;\n      if (rowIndexForPixel > lastRowIndex) {\n        return lastRowIndex;\n      }\n      return rowIndexForPixel;\n    }\n    return 0;\n  }\n  getRowCount() {\n    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;\n  }\n  isRowPresent(rowNode) {\n    const foundRowNode = this.getRowNode(rowNode.id);\n    return !!foundRowNode;\n  }\n  refreshCache() {\n    if (this.infiniteCache) {\n      this.infiniteCache.refreshCache();\n    }\n  }\n  purgeCache() {\n    if (this.infiniteCache) {\n      this.infiniteCache.purgeCache();\n    }\n  }\n  // for iRowModel\n  isLastRowIndexKnown() {\n    if (this.infiniteCache) {\n      return this.infiniteCache.isLastRowIndexKnown();\n    }\n    return false;\n  }\n  setRowCount(rowCount, lastRowIndexKnown) {\n    if (this.infiniteCache) {\n      this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);\n    }\n  }\n};\n\n// community-modules/infinite-row-model/src/infiniteRowModel/infiniteRowModelApi.ts\nfunction refreshInfiniteCache(beans) {\n  beans.rowModelHelperService?.getInfiniteRowModel()?.refreshCache();\n}\nfunction purgeInfiniteCache(beans) {\n  beans.rowModelHelperService?.getInfiniteRowModel()?.purgeCache();\n}\nfunction getInfiniteRowCount(beans) {\n  return beans.rowModelHelperService?.getInfiniteRowModel()?.getRowCount();\n}\nfunction isLastRowIndexKnown(beans) {\n  return beans.rowModelHelperService?.getInfiniteRowModel()?.isLastRowIndexKnown();\n}\n\n// community-modules/infinite-row-model/src/version.ts\nvar VERSION = \"32.0.0\";\n\n// community-modules/infinite-row-model/src/infiniteRowModelModule.ts\nvar InfiniteRowModelCoreModule = {\n  version: VERSION,\n  moduleName: `${ModuleNames.InfiniteRowModelModule}-core`,\n  rowModel: \"infinite\",\n  beans: [InfiniteRowModel],\n  dependantModules: [_RowNodeBlockModule]\n};\nvar InfiniteRowModelApiModule = {\n  version: VERSION,\n  moduleName: `${ModuleNames.InfiniteRowModelModule}-api`,\n  beans: [RowModelHelperService],\n  apiFunctions: {\n    refreshInfiniteCache,\n    purgeInfiniteCache,\n    getInfiniteRowCount,\n    isLastRowIndexKnown\n  },\n  dependantModules: [InfiniteRowModelCoreModule, _SsrmInfiniteSharedApiModule]\n};\nvar InfiniteRowModelModule = {\n  version: VERSION,\n  moduleName: ModuleNames.InfiniteRowModelModule,\n  dependantModules: [InfiniteRowModelCoreModule, InfiniteRowModelApiModule]\n};\nexport {\n  InfiniteRowModelModule\n};\n"],
  "mappings": "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",
  "names": ["ModuleNames", "RowModelHelperService", "_RowNodeBlockModule", "_SsrmInfiniteSharedApiModule", "BeanStub2", "NumberSequence2", "_jsonEquals", "_warnOnce2", "BeanStub", "NumberSequence", "_exists2", "_getAllValuesInObject", "_log", "RowNode", "RowNodeBlock", "_exists", "_missing", "_warnOnce", "InfiniteBlock", "beans", "id", "parentCache", "params", "rowNode", "data", "index", "callback", "sequence", "rowCount", "rowIndex", "dontTouchLastAccessed", "localIndex", "i", "finalRowCount", "MAX_EMPTY_BLOCKS_TO_KEEP", "InfiniteCache", "dontCreatePage", "blockId", "block", "blockNumber", "newBlock", "lastRow", "blockToExclude", "blocksForPurging", "b", "lastAccessedComparator", "a", "maxBlocksProvided", "blocksToKeep", "emptyBlocksToKeep", "purgeBecauseBlockEmpty", "purgeBecauseCacheFull", "focusedCell", "blockIndexStart", "blockIndexEnd", "startIndex", "endIndex", "blockToRemove", "lastRowIndexPlusOverflow", "lastRowIndexKnown", "blockComparator", "event", "blocksToDestroy", "firstInRange", "lastInRange", "result", "lastBlockId", "inActiveRange", "numberSequence", "foundGapInSelection", "hitFirstOrLast", "InfiniteRowModel", "resetRequired", "datasource", "node", "topLevelIndex", "pixel", "rowIndexForPixel", "lastRowIndex", "refreshInfiniteCache", "purgeInfiniteCache", "getInfiniteRowCount", "isLastRowIndexKnown", "VERSION", "InfiniteRowModelCoreModule", "InfiniteRowModelApiModule", "InfiniteRowModelModule"]
}
