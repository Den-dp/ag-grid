{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// enterprise-modules/clipboard/src/main.ts\nvar main_exports = {};\n__export(main_exports, {\n  ClipboardModule: () => ClipboardModule\n});\nmodule.exports = __toCommonJS(main_exports);\n\n// enterprise-modules/clipboard/src/clipboardModule.ts\nvar import_core2 = require(\"@ag-grid-community/core\");\nvar import_core3 = require(\"@ag-grid-enterprise/core\");\nvar import_csv_export = require(\"@ag-grid-community/csv-export\");\n\n// enterprise-modules/clipboard/src/clipboard/clipboardService.ts\nvar import_core = require(\"@ag-grid-community/core\");\nvar SOURCE_PASTE = \"paste\";\nvar EXPORT_TYPE_DRAG_COPY = \"dragCopy\";\nvar EXPORT_TYPE_CLIPBOARD = \"clipboard\";\nvar apiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`;\nvar ClipboardService = class extends import_core.BeanStub {\n  constructor() {\n    super(...arguments);\n    this.lastPasteOperationTime = 0;\n    this.navigatorApiFailed = false;\n  }\n  init() {\n    this.logger = this.loggerFactory.create(\"ClipboardService\");\n    if (this.rowModel.getType() === \"clientSide\") {\n      this.clientSideRowModel = this.rowModel;\n    }\n    this.ctrlsService.whenReady((p) => {\n      this.gridCtrl = p.gridCtrl;\n    });\n  }\n  pasteFromClipboard() {\n    this.logger.log(\"pasteFromClipboard\");\n    const allowNavigator = !this.gos.get(\"suppressClipboardApi\");\n    if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {\n      navigator.clipboard.readText().then(this.processClipboardData.bind(this)).catch((e) => {\n        import_core._.doOnce(() => {\n          console.warn(e);\n          console.warn(apiError(\"readText\"));\n        }, \"clipboardApiError\");\n        this.navigatorApiFailed = true;\n        this.pasteFromClipboardLegacy();\n      });\n    } else {\n      this.pasteFromClipboardLegacy();\n    }\n  }\n  pasteFromClipboardLegacy() {\n    let defaultPrevented = false;\n    const handlePasteEvent = (e) => {\n      const currentPastOperationTime = (/* @__PURE__ */ new Date()).getTime();\n      if (currentPastOperationTime - this.lastPasteOperationTime < 50) {\n        defaultPrevented = true;\n        e.preventDefault();\n      }\n      this.lastPasteOperationTime = currentPastOperationTime;\n    };\n    this.executeOnTempElement(\n      (textArea) => {\n        textArea.addEventListener(\"paste\", handlePasteEvent);\n        textArea.focus({ preventScroll: true });\n      },\n      (element) => {\n        const data = element.value;\n        if (!defaultPrevented) {\n          this.processClipboardData(data);\n        } else {\n          this.refocusLastFocusedCell();\n        }\n        element.removeEventListener(\"paste\", handlePasteEvent);\n      }\n    );\n  }\n  refocusLastFocusedCell() {\n    const focusedCell = this.focusService.getFocusedCell();\n    if (focusedCell) {\n      this.focusService.setFocusedCell({\n        rowIndex: focusedCell.rowIndex,\n        column: focusedCell.column,\n        rowPinned: focusedCell.rowPinned,\n        forceBrowserFocus: true\n      });\n    }\n  }\n  getClipboardDelimiter() {\n    const delimiter = this.gos.get(\"clipboardDelimiter\");\n    return import_core._.exists(delimiter) ? delimiter : \"\t\";\n  }\n  processClipboardData(data) {\n    if (data == null) {\n      return;\n    }\n    let parsedData = ClipboardService.stringToArray(data, this.getClipboardDelimiter());\n    const userFunc = this.gos.getCallback(\"processDataFromClipboard\");\n    if (userFunc) {\n      parsedData = userFunc({ data: parsedData });\n    }\n    if (parsedData == null) {\n      return;\n    }\n    if (this.gos.get(\"suppressLastEmptyLineOnPaste\")) {\n      this.removeLastLineIfBlank(parsedData);\n    }\n    const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {\n      var _a;\n      const rangeActive = (_a = this.rangeService) == null ? void 0 : _a.isMoreThanOneCell();\n      const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData);\n      if (pasteIntoRange) {\n        this.pasteIntoActiveRange(this.rangeService, parsedData, cellsToFlash, updatedRowNodes, changedPath);\n      } else {\n        this.pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n      }\n    };\n    this.doPasteOperation(pasteOperation);\n  }\n  // This will parse a delimited string into an array of arrays.\n  static stringToArray(strData, delimiter = \",\") {\n    const data = [];\n    const isNewline = (char) => char === \"\\r\" || char === \"\\n\";\n    let insideQuotedField = false;\n    if (strData === \"\") {\n      return [[\"\"]];\n    }\n    for (let row = 0, column = 0, position = 0; position < strData.length; position++) {\n      const previousChar = strData[position - 1];\n      const currentChar = strData[position];\n      const nextChar = strData[position + 1];\n      const ensureDataExists = () => {\n        if (!data[row]) {\n          data[row] = [];\n        }\n        if (!data[row][column]) {\n          data[row][column] = \"\";\n        }\n      };\n      ensureDataExists();\n      if (currentChar === '\"') {\n        if (insideQuotedField) {\n          if (nextChar === '\"') {\n            data[row][column] += '\"';\n            position++;\n          } else {\n            insideQuotedField = false;\n          }\n        } else if (previousChar === void 0 || previousChar === delimiter || isNewline(previousChar)) {\n          insideQuotedField = true;\n        }\n      }\n      if (!insideQuotedField && currentChar !== '\"') {\n        if (currentChar === delimiter) {\n          column++;\n          ensureDataExists();\n          continue;\n        } else if (isNewline(currentChar)) {\n          column = 0;\n          row++;\n          ensureDataExists();\n          if (currentChar === \"\\r\" && nextChar === \"\\n\") {\n            position++;\n          }\n          continue;\n        }\n      }\n      data[row][column] += currentChar;\n    }\n    return data;\n  }\n  // common code to paste operations, e.g. paste to cell, paste to range, and copy range down\n  doPasteOperation(pasteOperationFunc) {\n    const source = \"clipboard\";\n    this.eventService.dispatchEvent({\n      type: import_core.Events.EVENT_PASTE_START,\n      source\n    });\n    let changedPath;\n    if (this.clientSideRowModel) {\n      const onlyChangedColumns = this.gos.get(\"aggregateOnlyChangedColumns\");\n      changedPath = new import_core.ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n    }\n    const cellsToFlash = {};\n    const updatedRowNodes = [];\n    const focusedCell = this.focusService.getFocusedCell();\n    pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n    const nodesToRefresh = [...updatedRowNodes];\n    if (changedPath) {\n      this.clientSideRowModel.doAggregate(changedPath);\n      changedPath.forEachChangedNodeDepthFirst((rowNode) => {\n        nodesToRefresh.push(rowNode);\n      });\n    }\n    this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });\n    this.dispatchFlashCells(cellsToFlash);\n    this.fireRowChanged(updatedRowNodes);\n    this.refocusLastFocusedCell();\n    const event = {\n      type: import_core.Events.EVENT_PASTE_END,\n      source\n    };\n    this.eventService.dispatchEvent(event);\n  }\n  pasteIntoActiveRange(rangeService, clipboardData, cellsToFlash, updatedRowNodes, changedPath) {\n    const abortRepeatingPasteIntoRows = this.getRangeSize(rangeService) % clipboardData.length != 0;\n    let indexOffset = 0;\n    let dataRowIndex = 0;\n    const rowCallback = (currentRow, rowNode, columns, index) => {\n      const atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n      if (atEndOfClipboardData) {\n        if (abortRepeatingPasteIntoRows) {\n          return;\n        }\n        indexOffset += dataRowIndex;\n        dataRowIndex = 0;\n      }\n      const currentRowData = clipboardData[index - indexOffset];\n      updatedRowNodes.push(rowNode);\n      const processCellFromClipboardFunc = this.gos.getCallback(\"processCellFromClipboard\");\n      columns.forEach((column, idx) => {\n        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n          return;\n        }\n        if (idx >= currentRowData.length) {\n          idx = idx % currentRowData.length;\n        }\n        const newValue = this.processCell(\n          rowNode,\n          column,\n          currentRowData[idx],\n          EXPORT_TYPE_DRAG_COPY,\n          processCellFromClipboardFunc,\n          true\n        );\n        rowNode.setDataValue(column, newValue, SOURCE_PASTE);\n        if (changedPath) {\n          changedPath.addParentNode(rowNode.parent, [column]);\n        }\n        const { rowIndex, rowPinned } = currentRow;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      });\n      dataRowIndex++;\n    };\n    this.iterateActiveRanges(false, rowCallback);\n  }\n  getDisplayedColumnsStartingAt(column) {\n    let currentColumn = column;\n    const columns = [];\n    while (currentColumn != null) {\n      columns.push(currentColumn);\n      currentColumn = this.columnModel.getDisplayedColAfter(currentColumn);\n    }\n    return columns;\n  }\n  pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath) {\n    if (!focusedCell) {\n      return;\n    }\n    const currentRow = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };\n    const columnsToPasteInto = this.getDisplayedColumnsStartingAt(focusedCell.column);\n    if (this.isPasteSingleValueIntoRange(parsedData)) {\n      this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);\n    } else {\n      this.pasteMultipleValues(\n        parsedData,\n        currentRow,\n        updatedRowNodes,\n        columnsToPasteInto,\n        cellsToFlash,\n        EXPORT_TYPE_CLIPBOARD,\n        changedPath\n      );\n    }\n  }\n  // if range is active, and only one cell, then we paste this cell into all cells in the active range.\n  isPasteSingleValueIntoRange(parsedData) {\n    return this.hasOnlyOneValueToPaste(parsedData) && this.rangeService != null && !this.rangeService.isEmpty();\n  }\n  pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath) {\n    const value = parsedData[0][0];\n    const rowCallback = (currentRow, rowNode, columns) => {\n      updatedRowNodes.push(rowNode);\n      columns.forEach((column) => this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath));\n    };\n    this.iterateActiveRanges(false, rowCallback);\n  }\n  hasOnlyOneValueToPaste(parsedData) {\n    return parsedData.length === 1 && parsedData[0].length === 1;\n  }\n  copyRangeDown() {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const firstRowValues = [];\n    const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {\n      const processCellForClipboardFunc = this.gos.getCallback(\"processCellForClipboard\");\n      const processCellFromClipboardFunc = this.gos.getCallback(\"processCellFromClipboard\");\n      const rowCallback = (currentRow, rowNode, columns) => {\n        if (!firstRowValues.length) {\n          columns.forEach((column) => {\n            const value = this.processCell(\n              rowNode,\n              column,\n              this.valueService.getValue(column, rowNode),\n              EXPORT_TYPE_DRAG_COPY,\n              processCellForClipboardFunc,\n              false,\n              true\n            );\n            firstRowValues.push(value);\n          });\n        } else {\n          updatedRowNodes.push(rowNode);\n          columns.forEach((column, index) => {\n            if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n              return;\n            }\n            const firstRowValue = this.processCell(\n              rowNode,\n              column,\n              firstRowValues[index],\n              EXPORT_TYPE_DRAG_COPY,\n              processCellFromClipboardFunc,\n              true\n            );\n            rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);\n            if (changedPath) {\n              changedPath.addParentNode(rowNode.parent, [column]);\n            }\n            const { rowIndex, rowPinned } = currentRow;\n            const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n            cellsToFlash[cellId] = true;\n          });\n        }\n      };\n      this.iterateActiveRanges(true, rowCallback);\n    };\n    this.doPasteOperation(pasteOperation);\n  }\n  removeLastLineIfBlank(parsedData) {\n    const lastLine = import_core._.last(parsedData);\n    const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === \"\";\n    if (lastLineIsBlank) {\n      if (parsedData.length === 1) {\n        return;\n      }\n      import_core._.removeFromArray(parsedData, lastLine);\n    }\n  }\n  fireRowChanged(rowNodes) {\n    if (this.gos.get(\"editType\") !== \"fullRow\") {\n      return;\n    }\n    rowNodes.forEach((rowNode) => {\n      const event = {\n        type: import_core.Events.EVENT_ROW_VALUE_CHANGED,\n        node: rowNode,\n        data: rowNode.data,\n        rowIndex: rowNode.rowIndex,\n        rowPinned: rowNode.rowPinned\n      };\n      this.eventService.dispatchEvent(event);\n    });\n  }\n  pasteMultipleValues(clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, type, changedPath) {\n    let rowPointer = currentRow;\n    const skipGroupRows = this.clientSideRowModel != null && !this.gos.get(\"enableGroupEdit\") && !this.gos.get(\"treeData\");\n    const getNextGoodRowNode = () => {\n      while (true) {\n        if (!rowPointer) {\n          return null;\n        }\n        const res = this.rowPositionUtils.getRowNode(rowPointer);\n        rowPointer = this.cellNavigationService.getRowBelow({ rowPinned: rowPointer.rowPinned, rowIndex: rowPointer.rowIndex });\n        if (res == null) {\n          return null;\n        }\n        const skipRow = res.detail || res.footer || skipGroupRows && res.group;\n        if (!skipRow) {\n          return res;\n        }\n      }\n    };\n    clipboardGridData.forEach((clipboardRowData) => {\n      const rowNode = getNextGoodRowNode();\n      if (!rowNode) {\n        return;\n      }\n      clipboardRowData.forEach((value, index) => this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath));\n      updatedRowNodes.push(rowNode);\n    });\n  }\n  updateCellValue(rowNode, column, value, cellsToFlash, type, changedPath) {\n    if (!rowNode || !column || !column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {\n      return;\n    }\n    if (rowNode.group && column.isValueActive()) {\n      return;\n    }\n    const processedValue = this.processCell(rowNode, column, value, type, this.gos.getCallback(\"processCellFromClipboard\"), true);\n    rowNode.setDataValue(column, processedValue, SOURCE_PASTE);\n    const { rowIndex, rowPinned } = rowNode;\n    const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n    cellsToFlash[cellId] = true;\n    if (changedPath) {\n      changedPath.addParentNode(rowNode.parent, [column]);\n    }\n  }\n  copyToClipboard(params = {}) {\n    this.copyOrCutToClipboard(params);\n  }\n  cutToClipboard(params = {}, source = \"api\") {\n    if (this.gos.get(\"suppressCutToClipboard\")) {\n      return;\n    }\n    const startEvent = {\n      type: import_core.Events.EVENT_CUT_START,\n      source\n    };\n    this.eventService.dispatchEvent(startEvent);\n    this.copyOrCutToClipboard(params, true);\n    const endEvent = {\n      type: import_core.Events.EVENT_CUT_END,\n      source\n    };\n    this.eventService.dispatchEvent(endEvent);\n  }\n  copyOrCutToClipboard(params, cut) {\n    let { includeHeaders, includeGroupHeaders } = params;\n    this.logger.log(`copyToClipboard: includeHeaders = ${includeHeaders}`);\n    if (includeHeaders == null) {\n      includeHeaders = this.gos.get(\"copyHeadersToClipboard\");\n    }\n    if (includeGroupHeaders == null) {\n      includeGroupHeaders = this.gos.get(\"copyGroupHeadersToClipboard\");\n    }\n    const copyParams = { includeHeaders, includeGroupHeaders };\n    const shouldCopyRows = !this.gos.get(\"suppressCopyRowsToClipboard\");\n    let cellClearType = null;\n    if (this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange(this.rangeService)) {\n      this.copySelectedRangeToClipboard(copyParams);\n      cellClearType = 0 /* CellRange */;\n    } else if (shouldCopyRows && !this.selectionService.isEmpty()) {\n      this.copySelectedRowsToClipboard(copyParams);\n      cellClearType = 1 /* SelectedRows */;\n    } else if (this.focusService.isAnyCellFocused()) {\n      this.copyFocusedCellToClipboard(copyParams);\n      cellClearType = 2 /* FocusedCell */;\n    }\n    if (cut && cellClearType !== null) {\n      this.clearCellsAfterCopy(cellClearType);\n    }\n  }\n  clearCellsAfterCopy(type) {\n    this.eventService.dispatchEvent({ type: import_core.Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START });\n    if (type === 0 /* CellRange */) {\n      this.rangeService.clearCellRangeCellValues({ cellEventSource: \"clipboardService\" });\n    } else if (type === 1 /* SelectedRows */) {\n      this.clearSelectedRows();\n    } else {\n      const focusedCell = this.focusService.getFocusedCell();\n      if (focusedCell == null) {\n        return;\n      }\n      const rowNode = this.rowPositionUtils.getRowNode(focusedCell);\n      if (rowNode) {\n        this.clearCellValue(rowNode, focusedCell.column);\n      }\n    }\n    this.eventService.dispatchEvent({ type: import_core.Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });\n  }\n  clearSelectedRows() {\n    const selected = this.selectionService.getSelectedNodes();\n    const columns = this.columnModel.getAllDisplayedColumns();\n    for (const row of selected) {\n      for (const col of columns) {\n        this.clearCellValue(row, col);\n      }\n    }\n  }\n  clearCellValue(rowNode, column) {\n    var _a;\n    if (!column.isCellEditable(rowNode)) {\n      return;\n    }\n    const emptyValue = (_a = this.valueService.parseValue(column, rowNode, \"\", rowNode.getValueFromValueService(column))) != null ? _a : null;\n    rowNode.setDataValue(column, emptyValue, \"clipboardService\");\n  }\n  shouldSkipSingleCellRange(rangeService) {\n    return this.gos.get(\"suppressCopySingleCellRanges\") && !rangeService.isMoreThanOneCell();\n  }\n  iterateActiveRanges(onlyFirst, rowCallback, columnCallback) {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const cellRanges = this.rangeService.getCellRanges();\n    if (onlyFirst) {\n      this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);\n    } else {\n      cellRanges.forEach((range, idx) => this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1));\n    }\n  }\n  iterateActiveRange(range, rowCallback, columnCallback, isLastRange) {\n    if (!this.rangeService) {\n      return;\n    }\n    let currentRow = this.rangeService.getRangeStartRow(range);\n    const lastRow = this.rangeService.getRangeEndRow(range);\n    if (columnCallback && range.columns) {\n      columnCallback(range.columns);\n    }\n    let rangeIndex = 0;\n    let isLastRow = false;\n    while (!isLastRow && currentRow != null) {\n      const rowNode = this.rowPositionUtils.getRowNode(currentRow);\n      isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);\n      rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);\n      currentRow = this.cellNavigationService.getRowBelow(currentRow);\n    }\n  }\n  copySelectedRangeToClipboard(params = {}) {\n    if (!this.rangeService || this.rangeService.isEmpty()) {\n      return;\n    }\n    const allRangesMerge = this.rangeService.areAllRangesAbleToMerge();\n    const { data, cellsToFlash } = allRangesMerge ? this.buildDataFromMergedRanges(this.rangeService, params) : this.buildDataFromRanges(this.rangeService, params);\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells(cellsToFlash);\n  }\n  buildDataFromMergedRanges(rangeService, params) {\n    const columnsSet = /* @__PURE__ */ new Set();\n    const ranges = rangeService.getCellRanges();\n    const rowPositionsMap = /* @__PURE__ */ new Map();\n    const allRowPositions = [];\n    const allCellsToFlash = {};\n    ranges.forEach((range) => {\n      range.columns.forEach((col) => columnsSet.add(col));\n      const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeService, range);\n      rowPositions.forEach((rowPosition) => {\n        const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || \"null\"}`;\n        if (!rowPositionsMap.get(rowPositionAsString)) {\n          rowPositionsMap.set(rowPositionAsString, true);\n          allRowPositions.push(rowPosition);\n        }\n      });\n      Object.assign(allCellsToFlash, cellsToFlash);\n    });\n    const allColumns = this.columnModel.getAllDisplayedColumns();\n    const exportedColumns = Array.from(columnsSet);\n    exportedColumns.sort((a, b) => {\n      const posA = allColumns.indexOf(a);\n      const posB = allColumns.indexOf(b);\n      return posA - posB;\n    });\n    const data = this.buildExportParams({\n      columns: exportedColumns,\n      rowPositions: allRowPositions,\n      includeHeaders: params.includeHeaders,\n      includeGroupHeaders: params.includeGroupHeaders\n    });\n    return { data, cellsToFlash: allCellsToFlash };\n  }\n  buildDataFromRanges(rangeService, params) {\n    const ranges = rangeService.getCellRanges();\n    const data = [];\n    const allCellsToFlash = {};\n    ranges.forEach((range) => {\n      const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(rangeService, range);\n      Object.assign(allCellsToFlash, cellsToFlash);\n      data.push(this.buildExportParams({\n        columns: range.columns,\n        rowPositions,\n        includeHeaders: params.includeHeaders,\n        includeGroupHeaders: params.includeGroupHeaders\n      }));\n    });\n    return { data: data.join(\"\\n\"), cellsToFlash: allCellsToFlash };\n  }\n  getRangeRowPositionsAndCellsToFlash(rangeService, range) {\n    const rowPositions = [];\n    const cellsToFlash = {};\n    const startRow = rangeService.getRangeStartRow(range);\n    const lastRow = rangeService.getRangeEndRow(range);\n    let node = startRow;\n    while (node) {\n      rowPositions.push(node);\n      range.columns.forEach((column) => {\n        const { rowIndex, rowPinned } = node;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      });\n      if (this.rowPositionUtils.sameRow(node, lastRow)) {\n        break;\n      }\n      node = this.cellNavigationService.getRowBelow(node);\n    }\n    return { rowPositions, cellsToFlash };\n  }\n  getCellsToFlashFromRowNodes(rowNodes) {\n    const allDisplayedColumns = this.columnModel.getAllDisplayedColumns();\n    const cellsToFlash = {};\n    for (let i = 0; i < rowNodes.length; i++) {\n      const { rowIndex, rowPinned } = rowNodes[i];\n      if (rowIndex == null) {\n        continue;\n      }\n      for (let j = 0; j < allDisplayedColumns.length; j++) {\n        const column = allDisplayedColumns[j];\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n        cellsToFlash[cellId] = true;\n      }\n    }\n    return cellsToFlash;\n  }\n  copyFocusedCellToClipboard(params = {}) {\n    const focusedCell = this.focusService.getFocusedCell();\n    if (focusedCell == null) {\n      return;\n    }\n    const cellId = this.cellPositionUtils.createId(focusedCell);\n    const currentRow = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };\n    const column = focusedCell.column;\n    const data = this.buildExportParams({\n      columns: [column],\n      rowPositions: [currentRow],\n      includeHeaders: params.includeHeaders,\n      includeGroupHeaders: params.includeGroupHeaders\n    });\n    this.copyDataToClipboard(data);\n    this.dispatchFlashCells({ [cellId]: true });\n  }\n  copySelectedRowsToClipboard(params = {}) {\n    const { columnKeys, includeHeaders, includeGroupHeaders } = params;\n    const data = this.buildExportParams({\n      columns: columnKeys,\n      includeHeaders,\n      includeGroupHeaders\n    });\n    this.copyDataToClipboard(data);\n    const rowNodes = this.selectionService.getSelectedNodes() || [];\n    this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));\n  }\n  buildExportParams(params) {\n    const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;\n    const exportParams = {\n      columnKeys: columns,\n      rowPositions,\n      skipColumnHeaders: !includeHeaders,\n      skipColumnGroupHeaders: !includeGroupHeaders,\n      suppressQuotes: true,\n      columnSeparator: this.getClipboardDelimiter(),\n      onlySelected: !rowPositions,\n      processCellCallback: this.gos.getCallback(\"processCellForClipboard\"),\n      processRowGroupCallback: (params2) => this.processRowGroupCallback(params2),\n      processHeaderCallback: this.gos.getCallback(\"processHeaderForClipboard\"),\n      processGroupHeaderCallback: this.gos.getCallback(\"processGroupHeaderForClipboard\")\n    };\n    return this.csvCreator.getDataAsCsv(exportParams, true);\n  }\n  processRowGroupCallback(params) {\n    const { node, column } = params;\n    const isTreeData = this.gos.get(\"treeData\");\n    const isSuppressGroupMaintainValueType = this.gos.get(\"suppressGroupMaintainValueType\");\n    const getValueFromNode = () => {\n      var _a, _b;\n      if (isTreeData || isSuppressGroupMaintainValueType || !column) {\n        return node.key;\n      }\n      const value2 = (_a = node.groupData) == null ? void 0 : _a[column.getId()];\n      if (!value2 || !node.rowGroupColumn || node.rowGroupColumn.getColDef().useValueFormatterForExport === false) {\n        return value2;\n      }\n      return (_b = this.valueService.formatValue(node.rowGroupColumn, node, value2)) != null ? _b : value2;\n    };\n    let value = getValueFromNode();\n    if (params.node.footer) {\n      let suffix = \"\";\n      if (value && value.length) {\n        suffix = ` ${value}`;\n      }\n      value = `Total${suffix}`;\n    }\n    const processCellForClipboard = this.gos.getCallback(\"processCellForClipboard\");\n    if (processCellForClipboard) {\n      let column2 = node.rowGroupColumn;\n      if (!column2 && node.footer && node.level === -1) {\n        column2 = this.columnModel.getRowGroupColumns()[0];\n      }\n      return processCellForClipboard({\n        value,\n        node,\n        column: column2,\n        type: \"clipboard\",\n        formatValue: (valueToFormat) => {\n          var _a;\n          return (_a = this.valueService.formatValue(column2, node, valueToFormat)) != null ? _a : valueToFormat;\n        },\n        parseValue: (valueToParse) => this.valueService.parseValue(column2, node, valueToParse, this.valueService.getValue(column2, node))\n      });\n    }\n    return value;\n  }\n  dispatchFlashCells(cellsToFlash) {\n    window.setTimeout(() => {\n      const event = {\n        type: import_core.Events.EVENT_FLASH_CELLS,\n        cells: cellsToFlash\n      };\n      this.eventService.dispatchEvent(event);\n    }, 0);\n  }\n  processCell(rowNode, column, value, type, func, canParse, canFormat) {\n    var _a;\n    if (func) {\n      const params = {\n        column,\n        node: rowNode,\n        value,\n        type,\n        formatValue: (valueToFormat) => {\n          var _a2;\n          return (_a2 = this.valueService.formatValue(column, rowNode != null ? rowNode : null, valueToFormat)) != null ? _a2 : valueToFormat;\n        },\n        parseValue: (valueToParse) => this.valueService.parseValue(column, rowNode != null ? rowNode : null, valueToParse, this.valueService.getValue(column, rowNode))\n      };\n      return func(params);\n    }\n    if (canParse && column.getColDef().useValueParserForImport !== false) {\n      return this.valueService.parseValue(column, rowNode != null ? rowNode : null, value, this.valueService.getValue(column, rowNode));\n    }\n    if (canFormat && column.getColDef().useValueFormatterForExport !== false) {\n      return (_a = this.valueService.formatValue(column, rowNode != null ? rowNode : null, value)) != null ? _a : value;\n    }\n    return value;\n  }\n  copyDataToClipboard(data) {\n    const userProvidedFunc = this.gos.getCallback(\"sendToClipboard\");\n    if (userProvidedFunc) {\n      userProvidedFunc({ data });\n      return;\n    }\n    const allowNavigator = !this.gos.get(\"suppressClipboardApi\");\n    if (allowNavigator && navigator.clipboard) {\n      navigator.clipboard.writeText(data).catch((e) => {\n        import_core._.doOnce(() => {\n          console.warn(e);\n          console.warn(apiError(\"writeText\"));\n        }, \"clipboardApiError\");\n        this.copyDataToClipboardLegacy(data);\n      });\n      return;\n    }\n    this.copyDataToClipboardLegacy(data);\n  }\n  copyDataToClipboardLegacy(data) {\n    this.executeOnTempElement((element) => {\n      const eDocument = this.gos.getDocument();\n      const focusedElementBefore = this.gos.getActiveDomElement();\n      element.value = data || \" \";\n      element.select();\n      element.focus({ preventScroll: true });\n      const result = eDocument.execCommand(\"copy\");\n      if (!result) {\n        console.warn(\"AG Grid: Browser did not allow document.execCommand('copy'). Ensure api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.\");\n      }\n      if (focusedElementBefore != null && focusedElementBefore.focus != null) {\n        focusedElementBefore.focus({ preventScroll: true });\n      }\n    });\n  }\n  executeOnTempElement(callbackNow, callbackAfter) {\n    const eDoc = this.gos.getDocument();\n    const eTempInput = eDoc.createElement(\"textarea\");\n    eTempInput.style.width = \"1px\";\n    eTempInput.style.height = \"1px\";\n    eTempInput.style.top = eDoc.documentElement.scrollTop + \"px\";\n    eTempInput.style.left = eDoc.documentElement.scrollLeft + \"px\";\n    eTempInput.style.position = \"absolute\";\n    eTempInput.style.opacity = \"0\";\n    const guiRoot = this.gridCtrl.getGui();\n    guiRoot.appendChild(eTempInput);\n    try {\n      callbackNow(eTempInput);\n    } catch (err) {\n      console.warn(\"AG Grid: Browser does not support document.execCommand('copy') for clipboard operations\");\n    }\n    if (callbackAfter) {\n      window.setTimeout(() => {\n        callbackAfter(eTempInput);\n        guiRoot.removeChild(eTempInput);\n      }, 100);\n    } else {\n      guiRoot.removeChild(eTempInput);\n    }\n  }\n  getRangeSize(rangeService) {\n    const ranges = rangeService.getCellRanges();\n    let startRangeIndex = 0;\n    let endRangeIndex = 0;\n    if (ranges.length > 0) {\n      startRangeIndex = rangeService.getRangeStartRow(ranges[0]).rowIndex;\n      endRangeIndex = rangeService.getRangeEndRow(ranges[0]).rowIndex;\n    }\n    return startRangeIndex - endRangeIndex + 1;\n  }\n};\n__decorateClass([\n  (0, import_core.Autowired)(\"csvCreator\")\n], ClipboardService.prototype, \"csvCreator\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"loggerFactory\")\n], ClipboardService.prototype, \"loggerFactory\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"selectionService\")\n], ClipboardService.prototype, \"selectionService\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"rowModel\")\n], ClipboardService.prototype, \"rowModel\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"ctrlsService\")\n], ClipboardService.prototype, \"ctrlsService\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"valueService\")\n], ClipboardService.prototype, \"valueService\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"focusService\")\n], ClipboardService.prototype, \"focusService\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"rowRenderer\")\n], ClipboardService.prototype, \"rowRenderer\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"columnModel\")\n], ClipboardService.prototype, \"columnModel\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"cellNavigationService\")\n], ClipboardService.prototype, \"cellNavigationService\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"cellPositionUtils\")\n], ClipboardService.prototype, \"cellPositionUtils\", 2);\n__decorateClass([\n  (0, import_core.Autowired)(\"rowPositionUtils\")\n], ClipboardService.prototype, \"rowPositionUtils\", 2);\n__decorateClass([\n  (0, import_core.Optional)(\"rangeService\")\n], ClipboardService.prototype, \"rangeService\", 2);\n__decorateClass([\n  import_core.PostConstruct\n], ClipboardService.prototype, \"init\", 1);\nClipboardService = __decorateClass([\n  (0, import_core.Bean)(\"clipboardService\")\n], ClipboardService);\n\n// enterprise-modules/clipboard/src/version.ts\nvar VERSION = \"31.3.2\";\n\n// enterprise-modules/clipboard/src/clipboardModule.ts\nvar ClipboardModule = {\n  version: VERSION,\n  moduleName: import_core2.ModuleNames.ClipboardModule,\n  beans: [ClipboardService],\n  dependantModules: [\n    import_core3.EnterpriseCoreModule,\n    import_csv_export.CsvExportModule\n  ]\n};\n"],
  "mappings": "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",
  "names": ["target", "all", "name", "to", "from", "except", "desc", "key", "mod", "decorators", "kind", "result", "i", "decorator", "method", "p", "defaultPrevented", "handlePasteEvent", "e", "currentPastOperationTime", "textArea", "element", "data", "focusedCell", "delimiter", "parsedData", "userFunc", "pasteOperation", "cellsToFlash", "updatedRowNodes", "changedPath", "_a", "strData", "isNewline", "char", "insideQuotedField", "row", "column", "position", "previousChar", "currentChar", "nextChar", "ensureDataExists", "pasteOperationFunc", "source", "onlyChangedColumns", "nodesToRefresh", "rowNode", "event", "rangeService", "clipboardData", "abortRepeatingPasteIntoRows", "indexOffset", "dataRowIndex", "rowCallback", "currentRow", "columns", "index", "currentRowData", "processCellFromClipboardFunc", "idx", "newValue", "rowIndex", "rowPinned", "cellId", "currentColumn", "columnsToPasteInto", "value", "firstRowValues", "processCellForClipboardFunc", "firstRowValue", "lastLine", "rowNodes", "clipboardGridData", "type", "rowPointer", "skipGroupRows", "getNextGoodRowNode", "res", "clipboardRowData", "processedValue", "params", "startEvent", "endEvent", "cut", "includeHeaders", "includeGroupHeaders", "copyParams", "shouldCopyRows", "cellClearType", "selected", "col", "emptyValue", "onlyFirst", "columnCallback", "cellRanges", "range", "isLastRange", "lastRow", "rangeIndex", "isLastRow", "allRangesMerge", "columnsSet", "ranges", "rowPositionsMap", "allRowPositions", "allCellsToFlash", "rowPositions", "rowPosition", "rowPositionAsString", "allColumns", "exportedColumns", "a", "b", "posA", "posB", "startRow", "node", "allDisplayedColumns", "j", "columnKeys", "exportParams", "params2", "isTreeData", "isSuppressGroupMaintainValueType", "_b", "value2", "suffix", "processCellForClipboard", "column2", "valueToFormat", "valueToParse", "func", "canParse", "canFormat", "_a2", "userProvidedFunc", "eDocument", "focusedElementBefore", "callbackNow", "callbackAfter", "eDoc", "eTempInput", "guiRoot", "startRangeIndex", "endRangeIndex"]
}
