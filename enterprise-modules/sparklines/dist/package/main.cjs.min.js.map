{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// enterprise-modules/sparklines/src/main.ts\nvar main_exports = {};\n__export(main_exports, {\n  SparklinesModule: () => SparklinesModule\n});\nmodule.exports = __toCommonJS(main_exports);\n\n// enterprise-modules/sparklines/src/sparklinesModule.ts\nvar import_core6 = require(\"@ag-grid-community/core\");\nvar import_core7 = require(\"@ag-grid-enterprise/core\");\n\n// enterprise-modules/sparklines/src/sparklineCellRenderer.ts\nvar import_core4 = require(\"@ag-grid-community/core\");\n\n// enterprise-modules/sparklines/src/sparkline/agSparkline.ts\nvar import_core3 = require(\"@ag-grid-community/core\");\nvar import_ag_charts_community8 = require(\"ag-charts-community\");\n\n// enterprise-modules/sparklines/src/sparkline/area/areaSparkline.ts\nvar import_ag_charts_community3 = require(\"ag-charts-community\");\n\n// enterprise-modules/sparklines/src/util/lineDash.ts\nvar import_core = require(\"@ag-grid-community/core\");\nfunction getLineDash(lineCap, lineDash = \"solid\") {\n  const buttOrNull = {\n    solid: [],\n    dash: [4, 3],\n    dot: [1, 3],\n    dashDot: [4, 3, 1, 3],\n    dashDotDot: [4, 3, 1, 3, 1, 3],\n    shortDot: [1, 1],\n    shortDash: [3, 1],\n    shortDashDot: [3, 1, 1, 1],\n    shortDashDotDot: [3, 1, 1, 1, 1, 1],\n    longDash: [8, 3],\n    longDashDot: [8, 3, 1, 3],\n    longDashDotDot: [8, 3, 1, 3, 1, 3]\n  };\n  const roundOrSquare = {\n    solid: [],\n    dash: [3, 3],\n    dot: [0, 3],\n    dashDot: [3, 3, 0, 3],\n    dashDotDot: [3, 3, 0, 3, 0, 3],\n    shortDot: [0, 2],\n    shortDash: [2, 2],\n    shortDashDot: [2, 2, 0, 2],\n    shortDashDotDot: [2, 2, 0, 2, 0, 2],\n    longDash: [7, 3],\n    longDashDot: [7, 3, 0, 3],\n    longDashDotDot: [7, 3, 0, 3, 0, 3]\n  };\n  if (lineCap === \"round\" || lineCap === \"square\") {\n    if (roundOrSquare[lineDash] == void 0) {\n      warnInvalid(lineDash);\n      return roundOrSquare.solid;\n    }\n    return roundOrSquare[lineDash];\n  }\n  if (buttOrNull[lineDash] == void 0) {\n    warnInvalid(lineDash);\n    return buttOrNull.solid;\n  }\n  return buttOrNull[lineDash];\n}\nfunction warnInvalid(lineDash) {\n  (0, import_core._warnOnce)(`'${lineDash}' is not a valid 'lineDash' option.`);\n}\n\n// enterprise-modules/sparklines/src/sparkline/marker/markerFactory.ts\nvar import_ag_charts_community = require(\"ag-charts-community\");\nfunction getMarker(shape) {\n  switch (shape) {\n    case \"circle\":\n      return import_ag_charts_community._Scene.Circle;\n    case \"square\":\n      return import_ag_charts_community._Scene.Square;\n    case \"diamond\":\n      return import_ag_charts_community._Scene.Diamond;\n    default:\n      return import_ag_charts_community._Scene.Circle;\n  }\n}\n\n// enterprise-modules/sparklines/src/sparkline/sparkline.ts\nvar import_core2 = require(\"@ag-grid-community/core\");\nvar import_ag_charts_community2 = require(\"ag-charts-community\");\n\n// enterprise-modules/sparklines/src/sparkline/tooltip/defaultTooltipCss.ts\nvar defaultTooltipCss = `\n.ag-sparkline-tooltip-wrapper {\n    position: absolute;\n    user-select: none;\n    pointer-events: none;\n}\n\n.ag-sparkline-tooltip {\n    position: relative;\n    font: 12px arial,sans-serif;\n    border-radius: 2px;\n    box-shadow: 0 1px 3px rgb(0 0 0 / 20%), 0 1px 1px rgb(0 0 0 / 14%);\n    line-height: 1.7em;\n    overflow: hidden;\n    white-space: nowrap;\n    z-index: 99999;\n    background-color: rgb(255, 255, 255);\n    color: rgba(0,0,0, 0.67);\n}\n\n.ag-sparkline-tooltip-content {\n    padding: 0 7px;\n    opacity: 1;\n}\n\n.ag-sparkline-tooltip-title {\n    padding-left: 7px;\n    opacity: 1;\n}\n\n.ag-sparkline-tooltip-wrapper-hidden {\n    top: -10000px !important;\n}\n\n.ag-sparkline-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\n\n// enterprise-modules/sparklines/src/sparkline/sparkline.ts\nvar { extent, isNumber, isString, isStringObject, isDate, createId, Padding } = import_ag_charts_community2._Util;\nvar { LinearScale, BandScale, TimeScale } = import_ag_charts_community2._Scale;\nvar SparklineAxis = class {\n  constructor() {\n    this.type = \"category\";\n    this.stroke = \"rgb(204, 214, 235)\";\n    this.strokeWidth = 1;\n  }\n};\nvar _Sparkline = class _Sparkline {\n  constructor() {\n    this.id = createId(this);\n    this.seriesRect = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    this._context = void 0;\n    this._container = void 0;\n    this._data = void 0;\n    this.padding = new Padding(3);\n    this.xKey = \"x\";\n    this.yKey = \"y\";\n    this.dataType = void 0;\n    this.xData = [];\n    this.yData = [];\n    // Minimum y value in provided data.\n    this.min = void 0;\n    // Maximum y value in provided data.\n    this.max = void 0;\n    this.yScale = new LinearScale();\n    this.axis = new SparklineAxis();\n    this.highlightStyle = {\n      size: 6,\n      fill: \"yellow\",\n      stroke: \"silver\",\n      strokeWidth: 1\n    };\n    this._width = 100;\n    this._height = 100;\n    this.smallestInterval = void 0;\n    this.layoutId = 0;\n    this.defaultDateFormatter = new Intl.DateTimeFormat(\"en-US\", {\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hour12: false\n    });\n    this._onMouseMove = this.onMouseMove.bind(this);\n    this._onMouseOut = this.onMouseOut.bind(this);\n    const root = new import_ag_charts_community2._Scene.Group();\n    this.rootGroup = root;\n    const element = document.createElement(\"div\");\n    element.setAttribute(\"class\", \"ag-sparkline-wrapper\");\n    const scene = new import_ag_charts_community2._Scene.Scene({});\n    this.scene = scene;\n    this.canvasElement = scene.canvas.element;\n    scene.setRoot(root);\n    scene.setContainer(element);\n    this.resizeAndSetDimensions(this.width, this.height);\n    if (!_Sparkline.tooltipDocuments.includes(document)) {\n      this.initialiseTooltipStyles();\n    }\n    this.setupDomEventListeners(this.canvasElement);\n  }\n  set context(value) {\n    if (this._context !== value) {\n      this._context = value;\n    }\n  }\n  get context() {\n    return this._context;\n  }\n  set container(value) {\n    if (this._container !== value) {\n      const { parentNode } = this.canvasElement;\n      if (parentNode != null) {\n        parentNode.removeChild(this.canvasElement);\n      }\n      if (value) {\n        value.appendChild(this.canvasElement);\n      }\n      this._container = value;\n    }\n  }\n  get container() {\n    return this._container;\n  }\n  set data(value) {\n    if (this._data !== value) {\n      this._data = value;\n      this.processData();\n      if (this.mouseMoveEvent && this.highlightedDatum) {\n        this.updateHitPoint(this.mouseMoveEvent);\n      }\n    }\n  }\n  get data() {\n    return this._data;\n  }\n  resizeAndSetDimensions(width, height) {\n    this.scene.resize(width, height);\n    this.seriesRect.width = width;\n    this.seriesRect.height = height;\n  }\n  initialiseTooltipStyles() {\n    const styleElement = document.createElement(\"style\");\n    styleElement.innerHTML = defaultTooltipCss;\n    document.head.insertBefore(styleElement, document.head.querySelector(\"style\"));\n    _Sparkline.tooltipDocuments.push(document);\n  }\n  set width(value) {\n    if (this._width !== value) {\n      this._width = value;\n      this.scene.resize(value, this.height);\n      this.scheduleLayout();\n    }\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    if (this._height !== value) {\n      this._height = value;\n      this.scene.resize(this.width, value);\n      this.scheduleLayout();\n    }\n  }\n  get height() {\n    return this._height;\n  }\n  /**\n   * Generate node data from processed data.\n   * Produce data joins.\n   * Update selection's nodes using node data.\n   */\n  update() {\n  }\n  // Update y scale based on processed data.\n  updateYScale() {\n    this.updateYScaleRange();\n    this.updateYScaleDomain();\n  }\n  // Update y scale domain based on processed data.\n  updateYScaleDomain() {\n  }\n  // Update y scale range based on height and padding (seriesRect).\n  updateYScaleRange() {\n    const { yScale, seriesRect } = this;\n    yScale.range = [seriesRect.height, 0];\n  }\n  // Update x scale based on processed data.\n  updateXScale() {\n    const { type } = this.axis;\n    this.xScale = this.getXScale(type);\n    this.updateXScaleRange();\n    this.updateXScaleDomain();\n  }\n  // Update x scale range based on width and padding (seriesRect).\n  updateXScaleRange() {\n    this.xScale.range = [0, this.seriesRect.width];\n  }\n  // Update x scale domain based on processed data and type of scale.\n  updateXScaleDomain() {\n    const { xData, xScale } = this;\n    let xMinMax;\n    if (xScale instanceof LinearScale || xScale instanceof TimeScale) {\n      xMinMax = extent(xData);\n    }\n    this.xScale.domain = xMinMax ? xMinMax.slice() : xData;\n  }\n  /**\n   * Return xScale instance based on the provided type or return a `BandScale` by default.\n   * The default type is `category`.\n   * @param type\n   */\n  getXScale(type = \"category\") {\n    switch (type) {\n      case \"number\":\n        return new LinearScale();\n      case \"time\":\n        return new TimeScale();\n      case \"category\":\n      default:\n        return new BandScale();\n    }\n  }\n  // Update axis line.\n  updateAxisLine() {\n  }\n  // Update X and Y scales and the axis line.\n  updateAxes() {\n    this.updateYScale();\n    this.updateXScale();\n    this.updateAxisLine();\n  }\n  // Update horizontal and vertical crosshair lines.\n  updateCrosshairs() {\n    this.updateXCrosshairLine();\n    this.updateYCrosshairLine();\n  }\n  // Using processed data, generate data that backs visible nodes.\n  generateNodeData() {\n    return [];\n  }\n  // Returns persisted node data associated with the sparkline's data.\n  getNodeData() {\n    return [];\n  }\n  // Update the selection's nodes.\n  updateNodes() {\n  }\n  // Update the vertical crosshair line.\n  updateXCrosshairLine() {\n  }\n  // Update the horizontal crosshair line.\n  updateYCrosshairLine() {\n  }\n  highlightDatum(closestDatum) {\n    this.updateNodes();\n  }\n  dehighlightDatum() {\n    this.highlightedDatum = void 0;\n    this.updateNodes();\n    this.updateCrosshairs();\n  }\n  /**\n   * Highlight closest datum and display tooltip if enabled.\n   * Only update if necessary, i.e. only update if the highlighted datum is different from previously highlighted datum,\n   * or if there is no previously highlighted datum.\n   * @param event\n   */\n  onMouseMove(event) {\n    this.mouseMoveEvent = event;\n    this.updateHitPoint(event);\n  }\n  renderScene() {\n    this.scene.render().catch((e) => (0, import_core2._errorOnce)(`chart rendering failed`, e));\n  }\n  updateHitPoint(event) {\n    const closestDatum = this.pickClosestSeriesNodeDatum(event.offsetX, event.offsetY);\n    if (!closestDatum) {\n      return;\n    }\n    const oldHighlightedDatum = this.highlightedDatum;\n    this.highlightedDatum = closestDatum;\n    if (this.highlightedDatum && !oldHighlightedDatum || this.highlightedDatum && oldHighlightedDatum && this.highlightedDatum !== oldHighlightedDatum) {\n      this.highlightDatum(closestDatum);\n      this.updateCrosshairs();\n      this.renderScene();\n    }\n    const tooltipEnabled = this.processedOptions?.tooltip?.enabled ?? true;\n    if (tooltipEnabled) {\n      this.handleTooltip(event, closestDatum);\n    }\n  }\n  /**\n   * Dehighlight all nodes and remove tooltip.\n   * @param event\n   */\n  onMouseOut(event) {\n    this.dehighlightDatum();\n    this.tooltip.toggle(false);\n    this.renderScene();\n  }\n  // Fetch required values from the data object and process them.\n  processData() {\n    const { data, yData, xData } = this;\n    if (!data || this.invalidData(this.data)) {\n      return;\n    }\n    yData.length = 0;\n    xData.length = 0;\n    const n = data.length;\n    const dataType = this.getDataType(data);\n    this.dataType = dataType;\n    const { type: xValueType } = this.axis;\n    const xType = xValueType !== \"number\" && xValueType !== \"time\" ? \"category\" : xValueType;\n    const isContinuousX = xType === \"number\" || xType === \"time\";\n    const setSmallestXInterval = (curr, prev) => {\n      if (this.smallestInterval == void 0) {\n        this.smallestInterval = { x: Infinity, y: Infinity };\n      }\n      const { x } = this.smallestInterval;\n      const interval = Math.abs(curr - prev);\n      if (interval > 0 && interval < x) {\n        this.smallestInterval.x = interval;\n      }\n    };\n    let prevX;\n    if (dataType === \"number\") {\n      for (let i = 0; i < n; i++) {\n        const xDatum = i;\n        const yDatum = data[i];\n        const x = this.getDatum(xDatum, xType);\n        const y = this.getDatum(yDatum, \"number\");\n        if (isContinuousX) {\n          setSmallestXInterval(x, prevX);\n        }\n        xData.push(x);\n        yData.push(y);\n        prevX = x;\n      }\n    } else if (dataType === \"array\") {\n      for (let i = 0; i < n; i++) {\n        const datum = data[i];\n        if (Array.isArray(datum)) {\n          const xDatum = datum[0];\n          const yDatum = datum[1];\n          const x = this.getDatum(xDatum, xType);\n          const y = this.getDatum(yDatum, \"number\");\n          if (x == void 0) {\n            continue;\n          }\n          if (isContinuousX) {\n            setSmallestXInterval(x, prevX);\n          }\n          xData.push(x);\n          yData.push(y);\n          prevX = x;\n        }\n      }\n    } else if (dataType === \"object\") {\n      const { yKey, xKey } = this;\n      for (let i = 0; i < n; i++) {\n        const datum = data[i];\n        if (typeof datum === \"object\" && !Array.isArray(datum)) {\n          const xDatum = datum[xKey];\n          const yDatum = datum[yKey];\n          const x = this.getDatum(xDatum, xType);\n          const y = this.getDatum(yDatum, \"number\");\n          if (x == void 0) {\n            continue;\n          }\n          if (isContinuousX) {\n            setSmallestXInterval(x, prevX);\n          }\n          xData.push(x);\n          yData.push(y);\n          prevX = x;\n        }\n      }\n    }\n    this.updateAxes();\n    this.immediateLayout();\n  }\n  /**\n   * Return the type of data provided to the sparkline based on the first truthy value in the data array.\n   * If the value is not a number, array or object, return `undefined`.\n   * @param data\n   */\n  getDataType(data) {\n    for (const datum of data) {\n      if (datum != void 0) {\n        if (isNumber(datum)) {\n          return \"number\";\n        } else if (Array.isArray(datum)) {\n          return \"array\";\n        } else if (typeof datum === \"object\") {\n          return \"object\";\n        }\n      }\n    }\n  }\n  /**\n   * Return the given value depending on the type of axis.\n   * Return `undefined` if the value is invalid for the given axis type.\n   * @param value\n   */\n  getDatum(value, type) {\n    if (type === \"number\" && isNumber(value) || type === \"time\" && (isNumber(value) || isDate(value))) {\n      return value;\n    } else if (type === \"category\") {\n      if (isString(value) || isDate(value) || isNumber(value)) {\n        return { toString: () => String(value) };\n      } else if (isStringObject(value)) {\n        return value;\n      }\n    }\n  }\n  /**\n   * Only `true` while we are waiting for the layout to start.\n   * This will be `false` if the layout has already started and is ongoing.\n   */\n  get layoutScheduled() {\n    return !!this.layoutId;\n  }\n  /**\n   * Execute update method on the next available screen repaint to make changes to the canvas.\n   * If we are waiting for a layout to start and a new layout is requested,\n   * cancel the previous layout using the non 0 integer (this.layoutId) returned from requestAnimationFrame.\n   */\n  scheduleLayout() {\n    if (this.layoutId) {\n      cancelAnimationFrame(this.layoutId);\n    }\n    this.layoutId = requestAnimationFrame(() => {\n      this.immediateLayout();\n      this.layoutId = 0;\n    });\n  }\n  immediateLayout() {\n    this.setSparklineDimensions();\n    if (this.invalidData(this.data)) {\n      return;\n    }\n    this.updateXScaleRange();\n    this.updateYScaleRange();\n    this.updateAxisLine();\n    this.update();\n    this.renderScene();\n  }\n  setSparklineDimensions() {\n    const { width, height, padding, seriesRect, rootGroup } = this;\n    const shrunkWidth = width - padding.left - padding.right;\n    const shrunkHeight = height - padding.top - padding.bottom;\n    seriesRect.width = shrunkWidth;\n    seriesRect.height = shrunkHeight;\n    seriesRect.x = padding.left;\n    seriesRect.y = padding.top;\n    rootGroup.translationX = seriesRect.x;\n    rootGroup.translationY = seriesRect.y;\n  }\n  /**\n   * Return the closest data point to x/y canvas coordinates.\n   * @param x\n   * @param y\n   */\n  pickClosestSeriesNodeDatum(x, y) {\n    let minDistance = Infinity;\n    let closestDatum;\n    const hitPoint = this.rootGroup.transformPoint(x, y);\n    const nodeData = this.getNodeData();\n    for (let i = 0; i < nodeData.length; i++) {\n      const datum = nodeData[i];\n      if (!datum.point) {\n        return;\n      }\n      const distance = this.getDistance(hitPoint, datum.point);\n      if (distance <= minDistance) {\n        minDistance = distance;\n        closestDatum = datum;\n      }\n    }\n    return closestDatum;\n  }\n  /**\n   * Return the relevant distance between two points.\n   * The distance will be calculated based on the x value of the points for all sparklines except bar sparkline, where the distance is based on the y values.\n   * @param x\n   * @param y\n   */\n  getDistance(p1, p2) {\n    return Math.abs(p1.x - p2.x);\n  }\n  /**\n   * calculate x/y coordinates for tooltip based on coordinates of highlighted datum, position of canvas and page offset.\n   * @param datum\n   */\n  handleTooltip(event, datum) {\n    const { seriesDatum } = datum;\n    const { canvasElement } = this;\n    const { clientX, clientY } = event;\n    const tooltipOptions = this.processedOptions?.tooltip;\n    const meta = {\n      pageX: clientX,\n      pageY: clientY,\n      position: {\n        xOffset: tooltipOptions?.xOffset,\n        yOffset: tooltipOptions?.yOffset\n      },\n      container: tooltipOptions?.container\n    };\n    if (meta.container == void 0) {\n      meta.container = canvasElement;\n    }\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    let enabled = tooltipOptions?.enabled ?? true;\n    const tooltipRenderer = tooltipOptions?.renderer;\n    if (tooltipRenderer) {\n      const tooltipRendererResult = tooltipRenderer({\n        context: this.context,\n        datum: seriesDatum,\n        yValue,\n        xValue\n      });\n      enabled = typeof tooltipRendererResult !== \"string\" && tooltipRendererResult.enabled !== void 0 ? tooltipRendererResult.enabled : enabled;\n    }\n    const html = enabled && seriesDatum.y !== void 0 && this.getTooltipHtml(datum);\n    if (html) {\n      this.tooltip.show(meta, html);\n    }\n  }\n  formatNumericDatum(datum) {\n    return String(Math.round(datum * 10) / 10);\n  }\n  // locale.format('%m/%d/%y, %H:%M:%S');\n  formatDatum(datum) {\n    const type = this.axis.type || \"category\";\n    if (type === \"number\" && typeof datum === \"number\") {\n      return this.formatNumericDatum(datum);\n    } else if (type === \"time\" && (datum instanceof Date || isNumber(datum))) {\n      return this.defaultDateFormatter.format(datum);\n    } else {\n      return String(datum);\n    }\n  }\n  setupDomEventListeners(chartElement) {\n    chartElement.addEventListener(\"mousemove\", this._onMouseMove);\n    chartElement.addEventListener(\"mouseout\", this._onMouseOut);\n  }\n  cleanupDomEventListeners(chartElement) {\n    chartElement.removeEventListener(\"mousemove\", this._onMouseMove);\n    chartElement.removeEventListener(\"mouseout\", this._onMouseOut);\n  }\n  invalidData(data) {\n    return !data || !Array.isArray(data);\n  }\n  /**\n   * Cleanup and remove canvas element from the DOM.\n   */\n  destroy() {\n    this.cleanupDomEventListeners(this.canvasElement);\n    this.scene.destroy();\n    this.container = void 0;\n  }\n};\n_Sparkline.tooltipDocuments = [];\nvar Sparkline = _Sparkline;\n\n// enterprise-modules/sparklines/src/sparkline/tooltip/sparklineTooltip.ts\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return input;\n  }\n  defaults = defaults ?? {};\n  const {\n    content = defaults.content ?? \"\",\n    title = defaults.title ?? void 0,\n    color = defaults.color,\n    backgroundColor = defaults.backgroundColor,\n    opacity = defaults.opacity ?? 1\n  } = input;\n  let titleHtml;\n  let contentHtml;\n  if (color) {\n    titleHtml = title ? `<span class=\"${TooltipClass}-title\"; style=\"color: ${color}\">${title}</span>` : \"\";\n    contentHtml = `<span class=\"${TooltipClass}-content\" style=\"color: ${color}\">${content}</span>`;\n  } else {\n    titleHtml = title ? `<span class=\"${TooltipClass}-title\">${title}</span>` : \"\";\n    contentHtml = `<span class=\"${TooltipClass}-content\">${content}</span>`;\n  }\n  let style = `opacity: ${opacity}`;\n  if (backgroundColor) {\n    style += `; background-color: ${backgroundColor.toLowerCase()}`;\n  }\n  return `<div class=\"${TooltipClass}\" style=\"${style}\">\n                ${titleHtml}\n                ${contentHtml}\n            </div>`;\n}\nvar TooltipClass = \"ag-sparkline-tooltip\";\nvar SparklineTooltip = class {\n  constructor() {\n    this.element = document.createElement(\"div\");\n    const tooltipRoot = document.body;\n    tooltipRoot.appendChild(this.element);\n  }\n  isVisible() {\n    const { element } = this;\n    if (element.classList) {\n      return !element.classList.contains(`${TooltipClass}-wrapper-hidden`);\n    }\n    const classes = element.getAttribute(\"class\");\n    if (classes) {\n      return classes.split(\" \").indexOf(`${TooltipClass}-wrapper-hidden`) < 0;\n    }\n    return false;\n  }\n  updateClass(visible) {\n    const classList = [`${TooltipClass}-wrapper`];\n    if (visible !== true) {\n      classList.push(`${TooltipClass}-wrapper-hidden`);\n    }\n    this.element.setAttribute(\"class\", classList.join(\" \"));\n  }\n  show(meta, html) {\n    this.toggle(false);\n    const { element } = this;\n    if (html !== void 0) {\n      element.innerHTML = html;\n    } else if (!element.innerHTML) {\n      return;\n    }\n    const xOffset = meta.position?.xOffset ?? 10;\n    const yOffset = meta.position?.yOffset ?? 0;\n    let left = meta.pageX + xOffset;\n    let top = meta.pageY + yOffset;\n    const tooltipRect = element.getBoundingClientRect();\n    let maxLeft = window.innerWidth - tooltipRect.width;\n    if (meta.container) {\n      const containerRect = meta.container.getBoundingClientRect();\n      maxLeft = containerRect.left + (containerRect.width - tooltipRect.width);\n    }\n    if (left > maxLeft) {\n      left = meta.pageX - element.clientWidth - xOffset;\n    }\n    if (typeof scrollX !== \"undefined\") {\n      left += scrollX;\n    }\n    if (typeof scrollY !== \"undefined\") {\n      top += scrollY;\n    }\n    element.style.left = `${Math.round(left)}px`;\n    element.style.top = `${Math.round(top)}px`;\n    this.toggle(true);\n  }\n  toggle(visible) {\n    this.updateClass(visible);\n  }\n  destroy() {\n    const { parentNode } = this.element;\n    if (parentNode) {\n      parentNode.removeChild(this.element);\n    }\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/area/areaSparkline.ts\nvar { extent: extent2 } = import_ag_charts_community3._Util;\nvar { BandScale: BandScale2 } = import_ag_charts_community3._Scale;\nvar SparklineMarker = class {\n  constructor() {\n    this.enabled = true;\n    this.shape = \"circle\";\n    this.size = 0;\n    this.fill = \"rgb(124, 181, 236)\";\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n    this.formatter = void 0;\n  }\n};\nvar SparklineLine = class {\n  constructor() {\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n  }\n};\nvar SparklineCrosshairs = class {\n  constructor() {\n    this.xLine = {\n      enabled: true,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n    this.yLine = {\n      enabled: false,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n  }\n};\nvar AreaSparkline = class extends Sparkline {\n  constructor() {\n    super();\n    this.fill = \"rgba(124, 181, 236, 0.25)\";\n    this.strokePath = new import_ag_charts_community3._Scene.Path();\n    this.fillPath = new import_ag_charts_community3._Scene.Path();\n    this.xCrosshairLine = new import_ag_charts_community3._Scene.Line();\n    this.yCrosshairLine = new import_ag_charts_community3._Scene.Line();\n    this.areaSparklineGroup = new import_ag_charts_community3._Scene.Group();\n    this.xAxisLine = new import_ag_charts_community3._Scene.Line();\n    this.markers = new import_ag_charts_community3._Scene.Group();\n    this.markerSelection = import_ag_charts_community3._Scene.Selection.select(\n      this.markers,\n      () => this.markerFactory()\n    );\n    this.markerSelectionData = [];\n    this.marker = new SparklineMarker();\n    this.line = new SparklineLine();\n    this.crosshairs = new SparklineCrosshairs();\n    this.rootGroup.append(this.areaSparklineGroup);\n    this.xAxisLine.zIndex = 500 /* AXIS_LINE_ZINDEX */;\n    this.fillPath.zIndex = 50 /* SERIES_FILL_ZINDEX */;\n    this.strokePath.zIndex = 1e3 /* SERIES_STROKE_ZINDEX */;\n    this.xCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.yCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.markers.zIndex = 2500 /* SERIES_MARKERS_ZINDEX */;\n    this.areaSparklineGroup.append([\n      this.fillPath,\n      this.xAxisLine,\n      this.strokePath,\n      this.xCrosshairLine,\n      this.yCrosshairLine,\n      this.markers\n    ]);\n  }\n  markerFactory() {\n    const { shape } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  getNodeData() {\n    return this.markerSelectionData;\n  }\n  update() {\n    const data = this.generateNodeData();\n    if (!data) {\n      return;\n    }\n    const { nodeData, fillData, strokeData } = data;\n    this.markerSelectionData = nodeData;\n    this.updateSelection(nodeData);\n    this.updateNodes();\n    this.updateStroke(strokeData);\n    this.updateFill(fillData);\n  }\n  updateYScaleDomain() {\n    const { yData, yScale } = this;\n    const yMinMax = extent2(yData);\n    let yMin = 0;\n    let yMax = 1;\n    if (yMinMax !== void 0) {\n      yMin = this.min = yMinMax[0];\n      yMax = this.max = yMinMax[1];\n    }\n    yMin = yMin < 0 ? yMin : 0;\n    yMax = yMax < 0 ? 0 : yMax;\n    yScale.domain = [yMin, yMax];\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale } = this;\n    if (!data) {\n      return;\n    }\n    const continuous = !(xScale instanceof BandScale2);\n    const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n    const n = yData.length;\n    const nodeData = [];\n    const fillData = [];\n    const strokeData = [];\n    let firstValidX;\n    let lastValidX;\n    let previousX;\n    let nextX;\n    const yZero = yScale.convert(0);\n    for (let i = 0; i < n; i++) {\n      const yDatum = yData[i];\n      const xDatum = xData[i];\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n      const y = yDatum === void 0 ? NaN : yScale.convert(yDatum);\n      if (i + 1 < n) {\n        nextX = xScale.convert(continuous ? xScale.toDomain(xData[i + 1]) : xData[i + 1]) + offsetX;\n      }\n      strokeData.push({\n        seriesDatum: { x: xDatum, y: yDatum },\n        point: { x, y }\n      });\n      if (yDatum === void 0 && previousX !== void 0) {\n        fillData.push({ seriesDatum: void 0, point: { x: previousX, y: yZero } });\n        if (nextX !== void 0) {\n          fillData.push({ seriesDatum: void 0, point: { x: nextX, y: yZero } });\n        }\n      } else if (yDatum !== void 0) {\n        fillData.push({\n          seriesDatum: { x: xDatum, y: yDatum },\n          point: { x, y }\n        });\n        nodeData.push({\n          seriesDatum: { x: xDatum, y: yDatum },\n          point: { x, y }\n        });\n        firstValidX = firstValidX !== void 0 ? firstValidX : x;\n        lastValidX = x;\n      }\n      previousX = x;\n    }\n    fillData.push(\n      { seriesDatum: void 0, point: { x: lastValidX, y: yZero } },\n      { seriesDatum: void 0, point: { x: firstValidX, y: yZero } }\n    );\n    return { nodeData, fillData, strokeData };\n  }\n  updateAxisLine() {\n    const { xScale, yScale, axis, xAxisLine } = this;\n    xAxisLine.x1 = xScale.range[0];\n    xAxisLine.x2 = xScale.range[1];\n    xAxisLine.y1 = xAxisLine.y2 = 0;\n    xAxisLine.stroke = axis.stroke;\n    xAxisLine.strokeWidth = axis.strokeWidth;\n    const yZero = yScale.convert(0);\n    xAxisLine.translationY = yZero;\n  }\n  updateSelection(selectionData) {\n    this.markerSelection.update(selectionData);\n  }\n  updateNodes() {\n    const { highlightedDatum, highlightStyle, marker } = this;\n    const {\n      size: highlightSize,\n      fill: highlightFill,\n      stroke: highlightStroke,\n      strokeWidth: highlightStrokeWidth\n    } = highlightStyle;\n    const markerFormatter = marker.formatter;\n    this.markerSelection.each((node, datum, index) => {\n      const { point, seriesDatum } = datum;\n      if (!point) {\n        return;\n      }\n      const highlighted = datum === highlightedDatum;\n      const markerFill = highlighted && highlightFill !== void 0 ? highlightFill : marker.fill;\n      const markerStroke = highlighted && highlightStroke !== void 0 ? highlightStroke : marker.stroke;\n      const markerStrokeWidth = highlighted && highlightStrokeWidth !== void 0 ? highlightStrokeWidth : marker.strokeWidth;\n      const markerSize = highlighted && highlightSize !== void 0 ? highlightSize : marker.size;\n      let markerFormat;\n      if (markerFormatter) {\n        const first = index === 0;\n        const last = index === this.markerSelectionData.length - 1;\n        const min = seriesDatum.y === this.min;\n        const max = seriesDatum.y === this.max;\n        markerFormat = markerFormatter({\n          datum,\n          xValue: seriesDatum.x,\n          yValue: seriesDatum.y,\n          min,\n          max,\n          first,\n          last,\n          fill: markerFill,\n          stroke: markerStroke,\n          strokeWidth: markerStrokeWidth,\n          size: markerSize,\n          highlighted\n        });\n      }\n      node.size = markerFormat && markerFormat.size != void 0 ? markerFormat.size : markerSize;\n      node.fill = markerFormat && markerFormat.fill != void 0 ? markerFormat.fill : markerFill;\n      node.stroke = markerFormat && markerFormat.stroke != void 0 ? markerFormat.stroke : markerStroke;\n      node.strokeWidth = markerFormat && markerFormat.strokeWidth != void 0 ? markerFormat.strokeWidth : markerStrokeWidth;\n      node.translationX = point.x;\n      node.translationY = point.y;\n      node.visible = markerFormat && markerFormat.enabled != void 0 ? markerFormat.enabled : marker.enabled && node.size > 0;\n    });\n  }\n  updateStroke(strokeData) {\n    const { strokePath, yData, line } = this;\n    const path = strokePath.path;\n    path.clear();\n    if (yData.length < 2) {\n      return;\n    }\n    const n = strokeData.length;\n    let moveTo = true;\n    for (let i = 0; i < n; i++) {\n      const { point, seriesDatum } = strokeData[i];\n      const x = point.x;\n      const y = point.y;\n      if (seriesDatum.y == void 0) {\n        moveTo = true;\n      } else {\n        if (moveTo) {\n          path.moveTo(x, y);\n          moveTo = false;\n        } else {\n          path.lineTo(x, y);\n        }\n      }\n    }\n    strokePath.lineJoin = strokePath.lineCap = \"round\";\n    strokePath.fill = void 0;\n    strokePath.stroke = line.stroke;\n    strokePath.strokeWidth = line.strokeWidth;\n  }\n  updateFill(areaData) {\n    const { fillPath, yData, fill } = this;\n    const path = fillPath.path;\n    const n = areaData.length;\n    path.clear();\n    if (yData.length < 2) {\n      return;\n    }\n    for (let i = 0; i < n; i++) {\n      const { point } = areaData[i];\n      const x = point.x;\n      const y = point.y;\n      if (i > 0) {\n        path.lineTo(x, y);\n      } else {\n        path.moveTo(x, y);\n      }\n    }\n    path.closePath();\n    fillPath.lineJoin = \"round\";\n    fillPath.stroke = void 0;\n    fillPath.fill = fill;\n  }\n  updateXCrosshairLine() {\n    const {\n      yScale,\n      xCrosshairLine,\n      highlightedDatum,\n      crosshairs: { xLine }\n    } = this;\n    if (!xLine.enabled || highlightedDatum == void 0) {\n      xCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    xCrosshairLine.y1 = yScale.range[0];\n    xCrosshairLine.y2 = yScale.range[1];\n    xCrosshairLine.x1 = xCrosshairLine.x2 = 0;\n    xCrosshairLine.stroke = xLine.stroke;\n    xCrosshairLine.strokeWidth = xLine.strokeWidth ?? 1;\n    xCrosshairLine.lineCap = xLine.lineCap === \"round\" || xLine.lineCap === \"square\" ? xLine.lineCap : void 0;\n    const { lineDash } = xLine;\n    xCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(xCrosshairLine.lineCap, xLine.lineDash);\n    xCrosshairLine.translationX = highlightedDatum.point.x;\n  }\n  updateYCrosshairLine() {\n    const {\n      xScale,\n      yCrosshairLine,\n      highlightedDatum,\n      crosshairs: { yLine }\n    } = this;\n    if (!yLine.enabled || highlightedDatum == void 0) {\n      yCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    yCrosshairLine.x1 = xScale.range[0];\n    yCrosshairLine.x2 = xScale.range[1];\n    yCrosshairLine.y1 = yCrosshairLine.y2 = 0;\n    yCrosshairLine.stroke = yLine.stroke;\n    yCrosshairLine.strokeWidth = yLine.strokeWidth ?? 1;\n    yCrosshairLine.lineCap = yLine.lineCap === \"round\" || yLine.lineCap === \"square\" ? yLine.lineCap : void 0;\n    const { lineDash } = yLine;\n    yCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(yCrosshairLine.lineCap, yLine.lineDash);\n    yCrosshairLine.translationY = highlightedDatum.point.y;\n  }\n  getTooltipHtml(datum) {\n    const { dataType } = this;\n    const { seriesDatum } = datum;\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    const content = this.formatNumericDatum(yValue);\n    const title = dataType === \"array\" || dataType === \"object\" ? this.formatDatum(xValue) : void 0;\n    const defaults = {\n      content,\n      title\n    };\n    const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n    if (tooltipRenderer) {\n      return toTooltipHtml(\n        tooltipRenderer({\n          context: this.context,\n          datum: seriesDatum,\n          yValue,\n          xValue\n        }),\n        defaults\n      );\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barSparkline.ts\nvar import_ag_charts_community5 = require(\"ag-charts-community\");\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barColumnSparkline.ts\nvar import_ag_charts_community4 = require(\"ag-charts-community\");\n\n// enterprise-modules/sparklines/src/sparkline/label/label.ts\nvar Label = class {\n  constructor() {\n    this.enabled = true;\n    this.fontSize = 8;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.color = \"rgba(70, 70, 70, 1)\";\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barColumnSparkline.ts\nvar { extent: extent3 } = import_ag_charts_community4._Util;\nvar BarColumnLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.formatter = void 0;\n    this.placement = \"insideEnd\" /* InsideEnd */;\n  }\n};\nvar BarColumnSparkline = class extends Sparkline {\n  constructor() {\n    super();\n    this.fill = \"rgb(124, 181, 236)\";\n    this.stroke = \"silver\";\n    this.strokeWidth = 0;\n    this.paddingInner = 0.1;\n    this.paddingOuter = 0.2;\n    this.valueAxisDomain = void 0;\n    this.formatter = void 0;\n    this.axisLine = new import_ag_charts_community4._Scene.Line();\n    this.bandWidth = 0;\n    this.sparklineGroup = new import_ag_charts_community4._Scene.Group();\n    this.rectGroup = new import_ag_charts_community4._Scene.Group();\n    this.labelGroup = new import_ag_charts_community4._Scene.Group();\n    this.rectSelection = import_ag_charts_community4._Scene.Selection.select(\n      this.rectGroup,\n      import_ag_charts_community4._Scene.Rect\n    );\n    this.labelSelection = import_ag_charts_community4._Scene.Selection.select(\n      this.labelGroup,\n      import_ag_charts_community4._Scene.Text\n    );\n    this.nodeSelectionData = [];\n    this.label = new BarColumnLabel();\n    this.rootGroup.append(this.sparklineGroup);\n    this.rectGroup.zIndex = 50 /* SERIES_FILL_ZINDEX */;\n    this.axisLine.zIndex = 500 /* AXIS_LINE_ZINDEX */;\n    this.labelGroup.zIndex = 1500 /* SERIES_LABEL_ZINDEX */;\n    this.sparklineGroup.append([this.rectGroup, this.axisLine, this.labelGroup]);\n    this.axisLine.lineCap = \"round\";\n    this.label.enabled = false;\n  }\n  getNodeData() {\n    return this.nodeSelectionData;\n  }\n  update() {\n    this.updateSelections();\n    this.updateNodes();\n  }\n  updateSelections() {\n    const nodeData = this.generateNodeData();\n    if (!nodeData) {\n      return;\n    }\n    this.nodeSelectionData = nodeData;\n    this.updateRectSelection(nodeData);\n    this.updateLabelSelection(nodeData);\n  }\n  updateNodes() {\n    this.updateRectNodes();\n    this.updateLabelNodes();\n  }\n  calculateStep(range) {\n    const { xScale, paddingInner, paddingOuter, smallestInterval } = this;\n    const domainLength = xScale.domain[1] - xScale.domain[0];\n    const intervals = domainLength / (smallestInterval?.x ?? 1) + 1;\n    const maxBands = 50;\n    const bands = Math.min(intervals, maxBands);\n    const gaps = bands - 1;\n    const step = range / Math.max(1, 2 * paddingOuter + gaps * paddingInner + bands);\n    return step;\n  }\n  updateYScaleDomain() {\n    const { yScale, yData, valueAxisDomain } = this;\n    const yMinMax = extent3(yData);\n    let yMin = 0;\n    let yMax = 1;\n    if (yMinMax !== void 0) {\n      yMin = this.min = yMinMax[0];\n      yMax = this.max = yMinMax[1];\n    }\n    yMin = yMin < 0 ? yMin : 0;\n    yMax = yMax < 0 ? 0 : yMax;\n    if (valueAxisDomain) {\n      if (valueAxisDomain[1] < yMax) {\n        valueAxisDomain[1] = yMax;\n      }\n      if (valueAxisDomain[0] > yMin) {\n        valueAxisDomain[0] = yMin;\n      }\n    }\n    yScale.domain = valueAxisDomain ? valueAxisDomain : [yMin, yMax];\n  }\n  updateRectSelection(selectionData) {\n    this.rectSelection.update(selectionData);\n  }\n  updateRectNodes() {\n    const { highlightedDatum, formatter: nodeFormatter, fill, stroke, strokeWidth } = this;\n    const { fill: highlightFill, stroke: highlightStroke, strokeWidth: highlightStrokeWidth } = this.highlightStyle;\n    this.rectSelection.each((node, datum, index) => {\n      const highlighted = datum === highlightedDatum;\n      const nodeFill = highlighted && highlightFill !== void 0 ? highlightFill : fill;\n      const nodeStroke = highlighted && highlightStroke !== void 0 ? highlightStroke : stroke;\n      const nodeStrokeWidth = highlighted && highlightStrokeWidth !== void 0 ? highlightStrokeWidth : strokeWidth;\n      let nodeFormat;\n      const { x, y, width, height, seriesDatum } = datum;\n      if (nodeFormatter) {\n        const first = index === 0;\n        const last = index === this.nodeSelectionData.length - 1;\n        const min = seriesDatum.y === this.min;\n        const max = seriesDatum.y === this.max;\n        nodeFormat = nodeFormatter({\n          datum,\n          xValue: seriesDatum.x,\n          yValue: seriesDatum.y,\n          width,\n          height,\n          min,\n          max,\n          first,\n          last,\n          fill: nodeFill,\n          stroke: nodeStroke,\n          strokeWidth: nodeStrokeWidth,\n          highlighted\n        });\n      }\n      node.fill = nodeFormat && nodeFormat.fill || nodeFill;\n      node.stroke = nodeFormat && nodeFormat.stroke || nodeStroke;\n      node.strokeWidth = nodeFormat && nodeFormat.strokeWidth || nodeStrokeWidth;\n      node.x = node.y = 0;\n      node.width = width;\n      node.height = height;\n      node.visible = node.height > 0;\n      node.translationX = x;\n      node.translationY = y;\n    });\n  }\n  updateLabelSelection(selectionData) {\n    this.labelSelection.update(selectionData, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = import_ag_charts_community4._Scene.PointerEvents.None;\n    });\n  }\n  updateLabelNodes() {\n    const {\n      label: { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color }\n    } = this;\n    this.labelSelection.each((text, datum) => {\n      const label = datum.label;\n      if (label && labelEnabled) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(datum) {\n    const { dataType } = this;\n    const { seriesDatum } = datum;\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    const content = this.formatNumericDatum(yValue);\n    const title = dataType === \"array\" || dataType === \"object\" ? this.formatDatum(xValue) : void 0;\n    const defaults = {\n      content,\n      title\n    };\n    const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n    if (tooltipRenderer) {\n      return toTooltipHtml(\n        tooltipRenderer({\n          context: this.context,\n          datum: seriesDatum,\n          yValue,\n          xValue\n        }),\n        defaults\n      );\n    }\n    return toTooltipHtml(defaults);\n  }\n  formatLabelValue(value) {\n    return value % 1 !== 0 ? value.toFixed(1) : value.toFixed(0);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barSparkline.ts\nvar { isNumber: isNumber2 } = import_ag_charts_community5._Util;\nvar { BandScale: BandScale3 } = import_ag_charts_community5._Scale;\nvar BarSparkline = class extends BarColumnSparkline {\n  updateYScaleRange() {\n    const { seriesRect, yScale } = this;\n    yScale.range = [0, seriesRect.width];\n  }\n  updateXScaleRange() {\n    const { xScale, seriesRect, paddingOuter, paddingInner } = this;\n    if (xScale instanceof BandScale3) {\n      xScale.range = [0, seriesRect.height];\n      xScale.paddingInner = paddingInner;\n      xScale.paddingOuter = paddingOuter;\n    } else {\n      const step = this.calculateStep(seriesRect.height);\n      const padding = step * paddingOuter;\n      this.bandWidth = step * (1 - paddingInner);\n      xScale.range = [padding, seriesRect.height - padding - this.bandWidth];\n    }\n  }\n  updateAxisLine() {\n    const { yScale, axis, axisLine, seriesRect } = this;\n    const { strokeWidth } = axis;\n    axisLine.x1 = 0;\n    axisLine.x2 = 0;\n    axisLine.y1 = 0;\n    axisLine.y2 = seriesRect.height;\n    axisLine.stroke = axis.stroke;\n    axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);\n    const yZero = yScale.convert(0);\n    axisLine.translationX = yZero;\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;\n    if (!data) {\n      return;\n    }\n    const {\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor,\n      formatter: labelFormatter,\n      placement: labelPlacement\n    } = label;\n    const nodeData = [];\n    const yZero = yScale.convert(0);\n    const continuous = !(xScale instanceof BandScale3);\n    for (let i = 0, n = yData.length; i < n; i++) {\n      let yDatum = yData[i];\n      const xDatum = xData[i];\n      const invalidDatum = yDatum === void 0;\n      if (invalidDatum) {\n        yDatum = 0;\n      }\n      const y = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);\n      const x = Math.min(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const bottom = Math.max(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const height = !continuous ? xScale.bandwidth : this.bandWidth;\n      const width = bottom - x;\n      const midPoint = {\n        x: yZero,\n        y\n      };\n      let labelText;\n      if (labelFormatter) {\n        labelText = labelFormatter({ value: yDatum });\n      } else {\n        labelText = yDatum !== void 0 && isNumber2(yDatum) ? this.formatLabelValue(yDatum) : \"\";\n      }\n      const labelY = y + height / 2;\n      let labelX;\n      const labelTextBaseline = \"middle\";\n      let labelTextAlign;\n      const isPositiveY = yDatum !== void 0 && yDatum >= 0;\n      const labelPadding = 4;\n      if (labelPlacement === \"center\" /* Center */) {\n        labelX = x + width / 2;\n        labelTextAlign = \"center\";\n      } else if (labelPlacement === \"outsideEnd\" /* OutsideEnd */) {\n        labelX = x + (isPositiveY ? width + labelPadding : -labelPadding);\n        labelTextAlign = isPositiveY ? \"start\" : \"end\";\n      } else if (labelPlacement === \"insideEnd\" /* InsideEnd */) {\n        labelX = x + (isPositiveY ? width - labelPadding : labelPadding);\n        labelTextAlign = isPositiveY ? \"end\" : \"start\";\n        const textSize = import_ag_charts_community5._Scene.Text.getTextSize(labelText, labelFontFamily);\n        const textWidth = textSize.width || 20;\n        const positiveBoundary = yZero + textWidth;\n        const negativeBoundary = yZero - textWidth;\n        const exceedsBoundaries = isPositiveY && labelX < positiveBoundary || !isPositiveY && labelX > negativeBoundary;\n        if (exceedsBoundaries) {\n          labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);\n          labelTextAlign = isPositiveY ? \"start\" : \"end\";\n        }\n      } else {\n        labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);\n        labelTextAlign = isPositiveY ? \"start\" : \"end\";\n      }\n      nodeData.push({\n        x,\n        y,\n        width,\n        height,\n        fill,\n        stroke,\n        strokeWidth,\n        seriesDatum: { x: xDatum, y: invalidDatum ? void 0 : yDatum },\n        point: midPoint,\n        label: {\n          x: labelX,\n          y: labelY,\n          text: labelText,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          textAlign: labelTextAlign,\n          textBaseline: labelTextBaseline,\n          fill: labelColor\n        }\n      });\n    }\n    return nodeData;\n  }\n  getDistance(p1, p2) {\n    return Math.abs(p1.y - p2.y);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/columnSparkline.ts\nvar import_ag_charts_community6 = require(\"ag-charts-community\");\nvar { isNumber: isNumber3 } = import_ag_charts_community6._Util;\nvar { BandScale: BandScale4 } = import_ag_charts_community6._Scale;\nvar ColumnSparkline = class extends BarColumnSparkline {\n  updateYScaleRange() {\n    const { seriesRect, yScale } = this;\n    yScale.range = [seriesRect.height, 0];\n  }\n  updateXScaleRange() {\n    const { xScale, seriesRect, paddingOuter, paddingInner } = this;\n    if (xScale instanceof BandScale4) {\n      xScale.range = [0, seriesRect.width];\n      xScale.paddingInner = paddingInner;\n      xScale.paddingOuter = paddingOuter;\n    } else {\n      const step = this.calculateStep(seriesRect.width);\n      const padding = step * paddingOuter;\n      this.bandWidth = step * (1 - paddingInner);\n      xScale.range = [padding, seriesRect.width - padding - this.bandWidth];\n    }\n  }\n  updateAxisLine() {\n    const { yScale, axis, axisLine, seriesRect } = this;\n    const { strokeWidth } = axis;\n    axisLine.x1 = 0;\n    axisLine.x2 = seriesRect.width;\n    axisLine.y1 = 0;\n    axisLine.y2 = 0;\n    axisLine.stroke = axis.stroke;\n    axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);\n    const yZero = yScale.convert(0);\n    axisLine.translationY = yZero;\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;\n    if (!data) {\n      return;\n    }\n    const {\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor,\n      formatter: labelFormatter,\n      placement: labelPlacement\n    } = label;\n    const nodeData = [];\n    const yZero = yScale.convert(0);\n    const continuous = !(xScale instanceof BandScale4);\n    for (let i = 0, n = yData.length; i < n; i++) {\n      let yDatum = yData[i];\n      const xDatum = xData[i];\n      const invalidDatum = yDatum === void 0;\n      if (invalidDatum) {\n        yDatum = 0;\n      }\n      const y = Math.min(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);\n      const bottom = Math.max(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const width = !continuous ? xScale.bandwidth : this.bandWidth;\n      const height = bottom - y;\n      const midPoint = {\n        x: x + width / 2,\n        y: yZero\n      };\n      let labelText;\n      if (labelFormatter) {\n        labelText = labelFormatter({ value: yDatum });\n      } else {\n        labelText = yDatum !== void 0 && isNumber3(yDatum) ? this.formatLabelValue(yDatum) : \"\";\n      }\n      const labelX = x + width / 2;\n      let labelY;\n      const labelTextAlign = \"center\";\n      let labelTextBaseline;\n      const isPositiveY = yDatum !== void 0 && yDatum >= 0;\n      const labelPadding = 2;\n      if (labelPlacement === \"center\" /* Center */) {\n        labelY = y + height / 2;\n        labelTextBaseline = \"middle\";\n      } else if (labelPlacement === \"outsideEnd\" /* OutsideEnd */) {\n        labelY = y + (isPositiveY ? -labelPadding : height + labelPadding);\n        labelTextBaseline = isPositiveY ? \"bottom\" : \"top\";\n      } else if (labelPlacement === \"insideEnd\" /* InsideEnd */) {\n        labelY = y + (isPositiveY ? labelPadding : height - labelPadding);\n        labelTextBaseline = isPositiveY ? \"top\" : \"bottom\";\n        const textSize = import_ag_charts_community6._Scene.Text.getTextSize(labelText, labelFontFamily);\n        const textHeight = textSize.height || 10;\n        const positiveBoundary = yZero - textHeight;\n        const negativeBoundary = yZero + textHeight;\n        const exceedsBoundaries = isPositiveY && labelY > positiveBoundary || !isPositiveY && labelY < negativeBoundary;\n        if (exceedsBoundaries) {\n          labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);\n          labelTextBaseline = isPositiveY ? \"bottom\" : \"top\";\n        }\n      } else {\n        labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);\n        labelTextBaseline = isPositiveY ? \"bottom\" : \"top\";\n      }\n      nodeData.push({\n        x,\n        y,\n        width,\n        height,\n        fill,\n        stroke,\n        strokeWidth,\n        seriesDatum: { x: xDatum, y: invalidDatum ? void 0 : yDatum },\n        point: midPoint,\n        label: {\n          x: labelX,\n          y: labelY,\n          text: labelText,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          textAlign: labelTextAlign,\n          textBaseline: labelTextBaseline,\n          fill: labelColor\n        }\n      });\n    }\n    return nodeData;\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/line/lineSparkline.ts\nvar import_ag_charts_community7 = require(\"ag-charts-community\");\nvar { extent: extent4 } = import_ag_charts_community7._Util;\nvar { BandScale: BandScale5 } = import_ag_charts_community7._Scale;\nvar SparklineMarker2 = class {\n  constructor() {\n    this.enabled = true;\n    this.shape = \"circle\";\n    this.size = 0;\n    this.fill = \"rgb(124, 181, 236)\";\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n    this.formatter = void 0;\n  }\n};\nvar SparklineLine2 = class {\n  constructor() {\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n  }\n};\nvar SparklineCrosshairs2 = class {\n  constructor() {\n    this.xLine = {\n      enabled: true,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n    this.yLine = {\n      enabled: false,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n  }\n};\nvar LineSparkline = class extends Sparkline {\n  constructor() {\n    super();\n    this.linePath = new import_ag_charts_community7._Scene.Path();\n    this.xCrosshairLine = new import_ag_charts_community7._Scene.Line();\n    this.yCrosshairLine = new import_ag_charts_community7._Scene.Line();\n    this.lineSparklineGroup = new import_ag_charts_community7._Scene.Group();\n    this.markers = new import_ag_charts_community7._Scene.Group();\n    this.markerSelection = import_ag_charts_community7._Scene.Selection.select(\n      this.markers,\n      () => this.markerFactory()\n    );\n    this.markerSelectionData = [];\n    this.marker = new SparklineMarker2();\n    this.line = new SparklineLine2();\n    this.crosshairs = new SparklineCrosshairs2();\n    this.rootGroup.append(this.lineSparklineGroup);\n    this.linePath.zIndex = 1e3 /* SERIES_STROKE_ZINDEX */;\n    this.xCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.yCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.markers.zIndex = 2500 /* SERIES_MARKERS_ZINDEX */;\n    this.lineSparklineGroup.append([this.linePath, this.xCrosshairLine, this.yCrosshairLine, this.markers]);\n  }\n  getNodeData() {\n    return this.markerSelectionData;\n  }\n  markerFactory() {\n    const { shape } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  /**\n   * If marker shape is changed, this method should be called to remove the previous marker nodes selection.\n   */\n  onMarkerShapeChange() {\n    this.markerSelection = this.markerSelection.clear();\n    this.scheduleLayout();\n  }\n  update() {\n    const nodeData = this.generateNodeData();\n    if (!nodeData) {\n      return;\n    }\n    this.markerSelectionData = nodeData;\n    this.updateSelection(nodeData);\n    this.updateNodes();\n    this.updateLine();\n  }\n  updateYScaleDomain() {\n    const { yData, yScale } = this;\n    const yMinMax = extent4(yData);\n    let yMin = 0;\n    let yMax = 1;\n    if (yMinMax !== void 0) {\n      yMin = this.min = yMinMax[0];\n      yMax = this.max = yMinMax[1];\n    }\n    if (yMin === yMax) {\n      const padding = Math.abs(yMin * 0.01);\n      yMin -= padding;\n      yMax += padding;\n    }\n    yScale.domain = [yMin, yMax];\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale } = this;\n    if (!data) {\n      return;\n    }\n    const continuous = !(xScale instanceof BandScale5);\n    const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n    const nodeData = [];\n    for (let i = 0; i < yData.length; i++) {\n      const yDatum = yData[i];\n      const xDatum = xData[i];\n      if (yDatum == void 0) {\n        continue;\n      }\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n      const y = yDatum === void 0 ? NaN : yScale.convert(yDatum);\n      nodeData.push({\n        seriesDatum: { x: xDatum, y: yDatum },\n        point: { x, y }\n      });\n    }\n    return nodeData;\n  }\n  updateSelection(selectionData) {\n    this.markerSelection.update(selectionData);\n  }\n  updateNodes() {\n    const { highlightedDatum, highlightStyle, marker } = this;\n    const {\n      size: highlightSize,\n      fill: highlightFill,\n      stroke: highlightStroke,\n      strokeWidth: highlightStrokeWidth\n    } = highlightStyle;\n    const markerFormatter = marker.formatter;\n    this.markerSelection.each((node, datum, index) => {\n      const highlighted = datum === highlightedDatum;\n      const markerFill = highlighted && highlightFill !== void 0 ? highlightFill : marker.fill;\n      const markerStroke = highlighted && highlightStroke !== void 0 ? highlightStroke : marker.stroke;\n      const markerStrokeWidth = highlighted && highlightStrokeWidth !== void 0 ? highlightStrokeWidth : marker.strokeWidth;\n      const markerSize = highlighted && highlightSize !== void 0 ? highlightSize : marker.size;\n      let markerFormat;\n      const { seriesDatum, point } = datum;\n      if (markerFormatter) {\n        const first = index === 0;\n        const last = index === this.markerSelectionData.length - 1;\n        const min = seriesDatum.y === this.min;\n        const max = seriesDatum.y === this.max;\n        markerFormat = markerFormatter({\n          datum,\n          xValue: seriesDatum.x,\n          yValue: seriesDatum.y,\n          min,\n          max,\n          first,\n          last,\n          fill: markerFill,\n          stroke: markerStroke,\n          strokeWidth: markerStrokeWidth,\n          size: markerSize,\n          highlighted\n        });\n      }\n      node.size = markerFormat && markerFormat.size != void 0 ? markerFormat.size : markerSize;\n      node.fill = markerFormat && markerFormat.fill != void 0 ? markerFormat.fill : markerFill;\n      node.stroke = markerFormat && markerFormat.stroke != void 0 ? markerFormat.stroke : markerStroke;\n      node.strokeWidth = markerFormat && markerFormat.strokeWidth != void 0 ? markerFormat.strokeWidth : markerStrokeWidth;\n      node.translationX = point.x;\n      node.translationY = point.y;\n      node.visible = markerFormat && markerFormat.enabled != void 0 ? markerFormat.enabled : marker.enabled && node.size > 0;\n    });\n  }\n  updateLine() {\n    const { linePath, yData, xData, xScale, yScale, line } = this;\n    const path = linePath.path;\n    path.clear();\n    if (yData.length < 2) {\n      return;\n    }\n    const continuous = !(xScale instanceof BandScale5);\n    const n = yData.length;\n    const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n    let moveTo = true;\n    for (let i = 0; i < n; i++) {\n      const xDatum = xData[i];\n      const yDatum = yData[i];\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n      const y = yDatum === void 0 ? NaN : yScale.convert(yDatum);\n      if (yDatum == void 0) {\n        moveTo = true;\n      } else {\n        if (moveTo) {\n          path.moveTo(x, y);\n          moveTo = false;\n        } else {\n          path.lineTo(x, y);\n        }\n      }\n    }\n    linePath.fill = void 0;\n    linePath.stroke = line.stroke;\n    linePath.strokeWidth = line.strokeWidth;\n  }\n  updateXCrosshairLine() {\n    const {\n      yScale,\n      xCrosshairLine,\n      highlightedDatum,\n      crosshairs: { xLine }\n    } = this;\n    if (!xLine.enabled || highlightedDatum == void 0) {\n      xCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    xCrosshairLine.y1 = yScale.range[0];\n    xCrosshairLine.y2 = yScale.range[1];\n    xCrosshairLine.x1 = xCrosshairLine.x2 = 0;\n    xCrosshairLine.stroke = xLine.stroke;\n    xCrosshairLine.strokeWidth = xLine.strokeWidth ?? 1;\n    xCrosshairLine.lineCap = xLine.lineCap === \"round\" || xLine.lineCap === \"square\" ? xLine.lineCap : void 0;\n    const { lineDash } = xLine;\n    xCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(xCrosshairLine.lineCap, xLine.lineDash);\n    xCrosshairLine.translationX = highlightedDatum.point.x;\n  }\n  updateYCrosshairLine() {\n    const {\n      xScale,\n      yCrosshairLine,\n      highlightedDatum,\n      crosshairs: { yLine }\n    } = this;\n    if (!yLine.enabled || highlightedDatum == void 0) {\n      yCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    yCrosshairLine.x1 = xScale.range[0];\n    yCrosshairLine.x2 = xScale.range[1];\n    yCrosshairLine.y1 = yCrosshairLine.y2 = 0;\n    yCrosshairLine.stroke = yLine.stroke;\n    yCrosshairLine.strokeWidth = yLine.strokeWidth ?? 1;\n    yCrosshairLine.lineCap = yLine.lineCap === \"round\" || yLine.lineCap === \"square\" ? yLine.lineCap : void 0;\n    const { lineDash } = yLine;\n    yCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(yCrosshairLine.lineCap, yLine.lineDash);\n    yCrosshairLine.translationY = highlightedDatum.point.y;\n  }\n  getTooltipHtml(datum) {\n    const { dataType } = this;\n    const { seriesDatum } = datum;\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    const content = this.formatNumericDatum(yValue);\n    const title = dataType === \"array\" || dataType === \"object\" ? this.formatDatum(xValue) : void 0;\n    const defaults = {\n      content,\n      title\n    };\n    const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n    if (tooltipRenderer) {\n      return toTooltipHtml(\n        tooltipRenderer({\n          context: this.context,\n          datum: seriesDatum,\n          yValue,\n          xValue\n        }),\n        defaults\n      );\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/agSparkline.ts\nvar { isNumber: isNumber4 } = import_ag_charts_community8._Util;\nvar AgSparkline = class {\n  static create(options, tooltip) {\n    options = import_ag_charts_community8._Util.deepClone(options);\n    const sparkline = getSparklineInstance(options.type);\n    if (tooltip) {\n      sparkline.tooltip = tooltip;\n    }\n    initSparkline(sparkline, options);\n    initSparklineByType(sparkline, options);\n    if (options.data) {\n      sparkline.data = options.data;\n    }\n    sparkline.processedOptions = options;\n    return sparkline;\n  }\n};\nfunction getSparklineInstance(type = \"line\") {\n  switch (type) {\n    case \"column\":\n      return new ColumnSparkline();\n    case \"bar\":\n      return new BarSparkline();\n    case \"area\":\n      return new AreaSparkline();\n    case \"line\":\n    default:\n      return new LineSparkline();\n  }\n}\nfunction initSparklineByType(sparkline, options) {\n  switch (options.type) {\n    case \"bar\":\n      initBarColumnSparkline(sparkline, options);\n      break;\n    case \"column\":\n      initBarColumnSparkline(sparkline, options);\n      break;\n    case \"area\":\n      initAreaSparkline(sparkline, options);\n      break;\n    case \"line\":\n    default:\n      initLineSparkline(sparkline, options);\n      break;\n  }\n}\nfunction initSparkline(sparkline, options) {\n  setValueIfPropertyExists(sparkline, \"context\", options.context, options);\n  setValueIfPropertyExists(sparkline, \"width\", options.width, options);\n  setValueIfPropertyExists(sparkline, \"height\", options.height, options);\n  setValueIfPropertyExists(sparkline, \"container\", options.container, options);\n  setValueIfPropertyExists(sparkline, \"xKey\", options.xKey, options);\n  setValueIfPropertyExists(sparkline, \"yKey\", options.yKey, options);\n  if (options.padding) {\n    initPaddingOptions(sparkline.padding, options.padding);\n  }\n  if (options.axis) {\n    initAxisOptions(sparkline.axis, options.axis);\n  }\n  if (options.highlightStyle) {\n    initHighlightStyleOptions(sparkline.highlightStyle, options.highlightStyle);\n  }\n}\nfunction initLineSparkline(sparkline, options) {\n  if (options.marker) {\n    initMarkerOptions(sparkline.marker, options.marker);\n  }\n  if (options.line) {\n    initLineOptions(sparkline.line, options.line);\n  }\n  if (options.crosshairs) {\n    initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);\n  }\n}\nfunction initAreaSparkline(sparkline, options) {\n  setValueIfPropertyExists(sparkline, \"fill\", options.fill, options);\n  if (options.marker) {\n    initMarkerOptions(sparkline.marker, options.marker);\n  }\n  if (options.line) {\n    initLineOptions(sparkline.line, options.line);\n  }\n  if (options.crosshairs) {\n    initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);\n  }\n}\nfunction initBarColumnSparkline(sparkline, options) {\n  setValueIfPropertyExists(sparkline, \"valueAxisDomain\", options.valueAxisDomain, options);\n  setValueIfPropertyExists(sparkline, \"fill\", options.fill, options);\n  setValueIfPropertyExists(sparkline, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(sparkline, \"strokeWidth\", options.strokeWidth, options);\n  setValueIfPropertyExists(sparkline, \"paddingInner\", options.paddingInner, options);\n  setValueIfPropertyExists(sparkline, \"paddingOuter\", options.paddingOuter, options);\n  setValueIfPropertyExists(sparkline, \"formatter\", options.formatter, options);\n  if (options.label) {\n    initLabelOptions(sparkline.label, options.label);\n  }\n}\nfunction initPaddingOptions(target, options) {\n  setValueIfPropertyExists(target, \"top\", options.top, options);\n  setValueIfPropertyExists(target, \"right\", options.right, options);\n  setValueIfPropertyExists(target, \"bottom\", options.bottom, options);\n  setValueIfPropertyExists(target, \"left\", options.left, options);\n}\nfunction initMarkerOptions(target, options) {\n  setValueIfPropertyExists(target, \"enabled\", options.enabled, options);\n  setValueIfPropertyExists(target, \"size\", options.size, options);\n  setValueIfPropertyExists(target, \"shape\", options.shape, options);\n  setValueIfPropertyExists(target, \"fill\", options.fill, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n  setValueIfPropertyExists(target, \"formatter\", options.formatter, options);\n}\nfunction initLabelOptions(target, options) {\n  setValueIfPropertyExists(target, \"enabled\", options.enabled, options);\n  setValueIfPropertyExists(target, \"fontStyle\", options.fontStyle, options);\n  setValueIfPropertyExists(target, \"fontWeight\", options.fontWeight, options);\n  setValueIfPropertyExists(target, \"fontSize\", options.fontSize, options);\n  setValueIfPropertyExists(target, \"fontFamily\", options.fontFamily, options);\n  setValueIfPropertyExists(target, \"textAlign\", options.textAlign, options);\n  setValueIfPropertyExists(target, \"textBaseline\", options.textBaseline, options);\n  setValueIfPropertyExists(target, \"color\", options.color, options);\n  setValueIfPropertyExists(target, \"formatter\", options.formatter, options);\n  setValueIfPropertyExists(target, \"placement\", options.placement, options);\n}\nfunction initLineOptions(target, options) {\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n}\nfunction initAxisOptions(target, options) {\n  setValueIfPropertyExists(target, \"type\", options.type, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n}\nfunction initHighlightStyleOptions(target, options) {\n  setValueIfPropertyExists(target, \"fill\", options.fill, options);\n  setValueIfPropertyExists(target, \"size\", options.size, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n}\nfunction initCrosshairsOptions(target, options) {\n  if (target.xLine && options.xLine) {\n    initCrosshairLineOptions(target.xLine, options.xLine);\n  }\n  if (target.yLine && options.yLine) {\n    initCrosshairLineOptions(target.yLine, options.yLine);\n  }\n}\nfunction initCrosshairLineOptions(target, options) {\n  setValueIfPropertyExists(target, \"enabled\", options.enabled, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n  setValueIfPropertyExists(target, \"lineDash\", options.lineDash, options);\n  setValueIfPropertyExists(target, \"lineCap\", options.lineCap, options);\n}\nvar offsetValidator = (property, value, defaultOffset) => {\n  if (isNumber4(value)) {\n    return true;\n  }\n  (0, import_core3._warnOnce)(\n    `${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`\n  );\n  return false;\n};\nvar validators = {\n  xOffset: offsetValidator,\n  yOffset: offsetValidator\n};\nfunction setValueIfPropertyExists(target, property, value, options) {\n  if (property in options) {\n    if (property in target) {\n      const validator = validators[property];\n      const isValid = validator ? validator(property, value, target[property]) : true;\n      if (isValid && target[property] !== value) {\n        target[property] = value;\n      }\n    } else {\n      (0, import_core3._warnOnce)(`Property ${property} does not exist on the target object.`);\n    }\n  }\n}\n\n// enterprise-modules/sparklines/src/sparklineCellRenderer.ts\nvar SparklineCellRenderer = class extends import_core4.Component {\n  constructor() {\n    super(\n      /* html */\n      `<div class=\"ag-sparkline-wrapper\">\n            <span data-ref=\"eSparkline\"></span>\n        </div>`\n    );\n    this.eSparkline = import_core4.RefPlaceholder;\n  }\n  wireBeans(beans) {\n    this.resizeObserverService = beans.resizeObserverService;\n    this.sparklineTooltipSingleton = beans.sparklineTooltipSingleton;\n  }\n  init(params) {\n    let firstTimeIn = true;\n    const updateSparkline = () => {\n      const { clientWidth, clientHeight } = this.getGui();\n      if (clientWidth === 0 || clientHeight === 0) {\n        return;\n      }\n      if (firstTimeIn) {\n        const options = {\n          data: params.value,\n          width: clientWidth,\n          height: clientHeight,\n          context: {\n            data: params.data\n          },\n          ...params.sparklineOptions\n        };\n        this.sparkline = AgSparkline.create(options, this.sparklineTooltipSingleton.getSparklineTooltip());\n        this.eSparkline.appendChild(this.sparkline.canvasElement);\n        firstTimeIn = false;\n      } else {\n        this.sparkline.width = clientWidth;\n        this.sparkline.height = clientHeight;\n      }\n    };\n    const unsubscribeFromResize = this.resizeObserverService.observeResize(this.getGui(), updateSparkline);\n    this.addDestroyFunc(() => unsubscribeFromResize());\n  }\n  refresh(params) {\n    if (this.sparkline) {\n      this.sparkline.data = params.value;\n      return true;\n    }\n    return false;\n  }\n  destroy() {\n    if (this.sparkline) {\n      this.sparkline.destroy();\n    }\n    super.destroy();\n  }\n};\n\n// enterprise-modules/sparklines/src/tooltip/sparklineTooltipSingleton.ts\nvar import_core5 = require(\"@ag-grid-community/core\");\nvar SparklineTooltipSingleton = class extends import_core5.BeanStub {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"sparklineTooltipSingleton\";\n  }\n  postConstruct() {\n    this.tooltip = new SparklineTooltip();\n  }\n  getSparklineTooltip() {\n    return this.tooltip;\n  }\n  destroy() {\n    if (this.tooltip) {\n      this.tooltip.destroy();\n    }\n    super.destroy();\n  }\n};\n\n// enterprise-modules/sparklines/src/version.ts\nvar VERSION = \"32.0.0\";\n\n// enterprise-modules/sparklines/src/sparklinesModule.ts\nvar SparklinesModule = {\n  version: VERSION,\n  moduleName: import_core6.ModuleNames.SparklinesModule,\n  beans: [SparklineTooltipSingleton],\n  userComponents: [{ name: \"agSparklineCellRenderer\", classImp: SparklineCellRenderer }],\n  dependantModules: [import_core7.EnterpriseCoreModule]\n};\n"],
  "mappings": "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",
  "names": ["target", "all", "name", "to", "from", "except", "desc", "key", "mod", "lineCap", "lineDash", "buttOrNull", "roundOrSquare", "shape", "_Sparkline", "root", "element", "scene", "value", "parentNode", "width", "height", "styleElement", "yScale", "seriesRect", "type", "xData", "xScale", "xMinMax", "closestDatum", "event", "e", "oldHighlightedDatum", "data", "yData", "dataType", "xValueType", "xType", "isContinuousX", "setSmallestXInterval", "curr", "prev", "x", "interval", "prevX", "i", "xDatum", "yDatum", "y", "datum", "yKey", "xKey", "padding", "rootGroup", "shrunkWidth", "shrunkHeight", "minDistance", "hitPoint", "nodeData", "distance", "p1", "p2", "seriesDatum", "canvasElement", "clientX", "clientY", "tooltipOptions", "meta", "yValue", "xValue", "enabled", "tooltipRenderer", "tooltipRendererResult", "html", "chartElement", "input", "defaults", "content", "title", "color", "backgroundColor", "opacity", "titleHtml", "contentHtml", "style", "classes", "visible", "classList", "xOffset", "yOffset", "left", "top", "tooltipRect", "maxLeft", "containerRect", "MarkerShape", "fillData", "strokeData", "yMinMax", "yMin", "yMax", "continuous", "offsetX", "n", "firstValidX", "lastValidX", "previousX", "nextX", "yZero", "axis", "xAxisLine", "selectionData", "highlightedDatum", "highlightStyle", "marker", "highlightSize", "highlightFill", "highlightStroke", "highlightStrokeWidth", "markerFormatter", "node", "index", "point", "highlighted", "markerFill", "markerStroke", "markerStrokeWidth", "markerSize", "markerFormat", "first", "last", "min", "max", "strokePath", "line", "path", "moveTo", "areaData", "fillPath", "fill", "xCrosshairLine", "xLine", "yCrosshairLine", "yLine", "range", "paddingInner", "paddingOuter", "smallestInterval", "intervals", "bands", "gaps", "valueAxisDomain", "nodeFormatter", "stroke", "strokeWidth", "nodeFill", "nodeStroke", "nodeStrokeWidth", "nodeFormat", "text", "labelEnabled", "fontStyle", "fontWeight", "fontSize", "fontFamily", "label", "step", "axisLine", "labelFontStyle", "labelFontWeight", "labelFontSize", "labelFontFamily", "labelColor", "labelFormatter", "labelPlacement", "invalidDatum", "bottom", "midPoint", "labelText", "labelY", "labelX", "labelTextBaseline", "labelTextAlign", "isPositiveY", "labelPadding", "textWidth", "positiveBoundary", "negativeBoundary", "textHeight", "linePath", "options", "tooltip", "sparkline", "property", "defaultOffset", "validator", "beans", "params", "firstTimeIn", "updateSparkline", "clientWidth", "clientHeight", "unsubscribeFromResize"]
}
