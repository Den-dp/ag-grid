{
  "version": 3,
  "sources": ["<stdin>"],
  "sourcesContent": ["// enterprise-modules/sparklines/src/sparklinesModule.ts\nimport { ModuleNames } from \"@ag-grid-community/core\";\nimport { EnterpriseCoreModule } from \"@ag-grid-enterprise/core\";\n\n// enterprise-modules/sparklines/src/sparklineCellRenderer.ts\nimport { Component, RefPlaceholder } from \"@ag-grid-community/core\";\n\n// enterprise-modules/sparklines/src/sparkline/agSparkline.ts\nimport { _warnOnce as _warnOnce2 } from \"@ag-grid-community/core\";\nimport { _Util as _Util7 } from \"ag-charts-community\";\n\n// enterprise-modules/sparklines/src/sparkline/area/areaSparkline.ts\nimport { _Scale as _Scale2, _Scene as _Scene3, _Util as _Util2 } from \"ag-charts-community\";\n\n// enterprise-modules/sparklines/src/util/lineDash.ts\nimport { _warnOnce } from \"@ag-grid-community/core\";\nfunction getLineDash(lineCap, lineDash = \"solid\") {\n  const buttOrNull = {\n    solid: [],\n    dash: [4, 3],\n    dot: [1, 3],\n    dashDot: [4, 3, 1, 3],\n    dashDotDot: [4, 3, 1, 3, 1, 3],\n    shortDot: [1, 1],\n    shortDash: [3, 1],\n    shortDashDot: [3, 1, 1, 1],\n    shortDashDotDot: [3, 1, 1, 1, 1, 1],\n    longDash: [8, 3],\n    longDashDot: [8, 3, 1, 3],\n    longDashDotDot: [8, 3, 1, 3, 1, 3]\n  };\n  const roundOrSquare = {\n    solid: [],\n    dash: [3, 3],\n    dot: [0, 3],\n    dashDot: [3, 3, 0, 3],\n    dashDotDot: [3, 3, 0, 3, 0, 3],\n    shortDot: [0, 2],\n    shortDash: [2, 2],\n    shortDashDot: [2, 2, 0, 2],\n    shortDashDotDot: [2, 2, 0, 2, 0, 2],\n    longDash: [7, 3],\n    longDashDot: [7, 3, 0, 3],\n    longDashDotDot: [7, 3, 0, 3, 0, 3]\n  };\n  if (lineCap === \"round\" || lineCap === \"square\") {\n    if (roundOrSquare[lineDash] == void 0) {\n      warnInvalid(lineDash);\n      return roundOrSquare.solid;\n    }\n    return roundOrSquare[lineDash];\n  }\n  if (buttOrNull[lineDash] == void 0) {\n    warnInvalid(lineDash);\n    return buttOrNull.solid;\n  }\n  return buttOrNull[lineDash];\n}\nfunction warnInvalid(lineDash) {\n  _warnOnce(`'${lineDash}' is not a valid 'lineDash' option.`);\n}\n\n// enterprise-modules/sparklines/src/sparkline/marker/markerFactory.ts\nimport { _Scene } from \"ag-charts-community\";\nfunction getMarker(shape) {\n  switch (shape) {\n    case \"circle\":\n      return _Scene.Circle;\n    case \"square\":\n      return _Scene.Square;\n    case \"diamond\":\n      return _Scene.Diamond;\n    default:\n      return _Scene.Circle;\n  }\n}\n\n// enterprise-modules/sparklines/src/sparkline/sparkline.ts\nimport { _errorOnce } from \"@ag-grid-community/core\";\nimport { _Scale, _Scene as _Scene2, _Util } from \"ag-charts-community\";\n\n// enterprise-modules/sparklines/src/sparkline/tooltip/defaultTooltipCss.ts\nvar defaultTooltipCss = `\n.ag-sparkline-tooltip-wrapper {\n    position: absolute;\n    user-select: none;\n    pointer-events: none;\n}\n\n.ag-sparkline-tooltip {\n    position: relative;\n    font: 12px arial,sans-serif;\n    border-radius: 2px;\n    box-shadow: 0 1px 3px rgb(0 0 0 / 20%), 0 1px 1px rgb(0 0 0 / 14%);\n    line-height: 1.7em;\n    overflow: hidden;\n    white-space: nowrap;\n    z-index: 99999;\n    background-color: rgb(255, 255, 255);\n    color: rgba(0,0,0, 0.67);\n}\n\n.ag-sparkline-tooltip-content {\n    padding: 0 7px;\n    opacity: 1;\n}\n\n.ag-sparkline-tooltip-title {\n    padding-left: 7px;\n    opacity: 1;\n}\n\n.ag-sparkline-tooltip-wrapper-hidden {\n    top: -10000px !important;\n}\n\n.ag-sparkline-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\n\n// enterprise-modules/sparklines/src/sparkline/sparkline.ts\nvar { extent, isNumber, isString, isStringObject, isDate, createId, Padding } = _Util;\nvar { LinearScale, BandScale, TimeScale } = _Scale;\nvar SparklineAxis = class {\n  constructor() {\n    this.type = \"category\";\n    this.stroke = \"rgb(204, 214, 235)\";\n    this.strokeWidth = 1;\n  }\n};\nvar _Sparkline = class _Sparkline {\n  constructor() {\n    this.id = createId(this);\n    this.seriesRect = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    this._context = void 0;\n    this._container = void 0;\n    this._data = void 0;\n    this.padding = new Padding(3);\n    this.xKey = \"x\";\n    this.yKey = \"y\";\n    this.dataType = void 0;\n    this.xData = [];\n    this.yData = [];\n    // Minimum y value in provided data.\n    this.min = void 0;\n    // Maximum y value in provided data.\n    this.max = void 0;\n    this.yScale = new LinearScale();\n    this.axis = new SparklineAxis();\n    this.highlightStyle = {\n      size: 6,\n      fill: \"yellow\",\n      stroke: \"silver\",\n      strokeWidth: 1\n    };\n    this._width = 100;\n    this._height = 100;\n    this.smallestInterval = void 0;\n    this.layoutId = 0;\n    this.defaultDateFormatter = new Intl.DateTimeFormat(\"en-US\", {\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      hour12: false\n    });\n    this._onMouseMove = this.onMouseMove.bind(this);\n    this._onMouseOut = this.onMouseOut.bind(this);\n    const root = new _Scene2.Group();\n    this.rootGroup = root;\n    const element = document.createElement(\"div\");\n    element.setAttribute(\"class\", \"ag-sparkline-wrapper\");\n    const scene = new _Scene2.Scene({});\n    this.scene = scene;\n    this.canvasElement = scene.canvas.element;\n    scene.setRoot(root);\n    scene.setContainer(element);\n    this.resizeAndSetDimensions(this.width, this.height);\n    if (!_Sparkline.tooltipDocuments.includes(document)) {\n      this.initialiseTooltipStyles();\n    }\n    this.setupDomEventListeners(this.canvasElement);\n  }\n  set context(value) {\n    if (this._context !== value) {\n      this._context = value;\n    }\n  }\n  get context() {\n    return this._context;\n  }\n  set container(value) {\n    if (this._container !== value) {\n      const { parentNode } = this.canvasElement;\n      if (parentNode != null) {\n        parentNode.removeChild(this.canvasElement);\n      }\n      if (value) {\n        value.appendChild(this.canvasElement);\n      }\n      this._container = value;\n    }\n  }\n  get container() {\n    return this._container;\n  }\n  set data(value) {\n    if (this._data !== value) {\n      this._data = value;\n      this.processData();\n      if (this.mouseMoveEvent && this.highlightedDatum) {\n        this.updateHitPoint(this.mouseMoveEvent);\n      }\n    }\n  }\n  get data() {\n    return this._data;\n  }\n  resizeAndSetDimensions(width, height) {\n    this.scene.resize(width, height);\n    this.seriesRect.width = width;\n    this.seriesRect.height = height;\n  }\n  initialiseTooltipStyles() {\n    const styleElement = document.createElement(\"style\");\n    styleElement.innerHTML = defaultTooltipCss;\n    document.head.insertBefore(styleElement, document.head.querySelector(\"style\"));\n    _Sparkline.tooltipDocuments.push(document);\n  }\n  set width(value) {\n    if (this._width !== value) {\n      this._width = value;\n      this.scene.resize(value, this.height);\n      this.scheduleLayout();\n    }\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    if (this._height !== value) {\n      this._height = value;\n      this.scene.resize(this.width, value);\n      this.scheduleLayout();\n    }\n  }\n  get height() {\n    return this._height;\n  }\n  /**\n   * Generate node data from processed data.\n   * Produce data joins.\n   * Update selection's nodes using node data.\n   */\n  update() {\n  }\n  // Update y scale based on processed data.\n  updateYScale() {\n    this.updateYScaleRange();\n    this.updateYScaleDomain();\n  }\n  // Update y scale domain based on processed data.\n  updateYScaleDomain() {\n  }\n  // Update y scale range based on height and padding (seriesRect).\n  updateYScaleRange() {\n    const { yScale, seriesRect } = this;\n    yScale.range = [seriesRect.height, 0];\n  }\n  // Update x scale based on processed data.\n  updateXScale() {\n    const { type } = this.axis;\n    this.xScale = this.getXScale(type);\n    this.updateXScaleRange();\n    this.updateXScaleDomain();\n  }\n  // Update x scale range based on width and padding (seriesRect).\n  updateXScaleRange() {\n    this.xScale.range = [0, this.seriesRect.width];\n  }\n  // Update x scale domain based on processed data and type of scale.\n  updateXScaleDomain() {\n    const { xData, xScale } = this;\n    let xMinMax;\n    if (xScale instanceof LinearScale || xScale instanceof TimeScale) {\n      xMinMax = extent(xData);\n    }\n    this.xScale.domain = xMinMax ? xMinMax.slice() : xData;\n  }\n  /**\n   * Return xScale instance based on the provided type or return a `BandScale` by default.\n   * The default type is `category`.\n   * @param type\n   */\n  getXScale(type = \"category\") {\n    switch (type) {\n      case \"number\":\n        return new LinearScale();\n      case \"time\":\n        return new TimeScale();\n      case \"category\":\n      default:\n        return new BandScale();\n    }\n  }\n  // Update axis line.\n  updateAxisLine() {\n  }\n  // Update X and Y scales and the axis line.\n  updateAxes() {\n    this.updateYScale();\n    this.updateXScale();\n    this.updateAxisLine();\n  }\n  // Update horizontal and vertical crosshair lines.\n  updateCrosshairs() {\n    this.updateXCrosshairLine();\n    this.updateYCrosshairLine();\n  }\n  // Using processed data, generate data that backs visible nodes.\n  generateNodeData() {\n    return [];\n  }\n  // Returns persisted node data associated with the sparkline's data.\n  getNodeData() {\n    return [];\n  }\n  // Update the selection's nodes.\n  updateNodes() {\n  }\n  // Update the vertical crosshair line.\n  updateXCrosshairLine() {\n  }\n  // Update the horizontal crosshair line.\n  updateYCrosshairLine() {\n  }\n  highlightDatum(closestDatum) {\n    this.updateNodes();\n  }\n  dehighlightDatum() {\n    this.highlightedDatum = void 0;\n    this.updateNodes();\n    this.updateCrosshairs();\n  }\n  /**\n   * Highlight closest datum and display tooltip if enabled.\n   * Only update if necessary, i.e. only update if the highlighted datum is different from previously highlighted datum,\n   * or if there is no previously highlighted datum.\n   * @param event\n   */\n  onMouseMove(event) {\n    this.mouseMoveEvent = event;\n    this.updateHitPoint(event);\n  }\n  renderScene() {\n    this.scene.render().catch((e) => _errorOnce(`chart rendering failed`, e));\n  }\n  updateHitPoint(event) {\n    const closestDatum = this.pickClosestSeriesNodeDatum(event.offsetX, event.offsetY);\n    if (!closestDatum) {\n      return;\n    }\n    const oldHighlightedDatum = this.highlightedDatum;\n    this.highlightedDatum = closestDatum;\n    if (this.highlightedDatum && !oldHighlightedDatum || this.highlightedDatum && oldHighlightedDatum && this.highlightedDatum !== oldHighlightedDatum) {\n      this.highlightDatum(closestDatum);\n      this.updateCrosshairs();\n      this.renderScene();\n    }\n    const tooltipEnabled = this.processedOptions?.tooltip?.enabled ?? true;\n    if (tooltipEnabled) {\n      this.handleTooltip(event, closestDatum);\n    }\n  }\n  /**\n   * Dehighlight all nodes and remove tooltip.\n   * @param event\n   */\n  onMouseOut(event) {\n    this.dehighlightDatum();\n    this.tooltip.toggle(false);\n    this.renderScene();\n  }\n  // Fetch required values from the data object and process them.\n  processData() {\n    const { data, yData, xData } = this;\n    if (!data || this.invalidData(this.data)) {\n      return;\n    }\n    yData.length = 0;\n    xData.length = 0;\n    const n = data.length;\n    const dataType = this.getDataType(data);\n    this.dataType = dataType;\n    const { type: xValueType } = this.axis;\n    const xType = xValueType !== \"number\" && xValueType !== \"time\" ? \"category\" : xValueType;\n    const isContinuousX = xType === \"number\" || xType === \"time\";\n    const setSmallestXInterval = (curr, prev) => {\n      if (this.smallestInterval == void 0) {\n        this.smallestInterval = { x: Infinity, y: Infinity };\n      }\n      const { x } = this.smallestInterval;\n      const interval = Math.abs(curr - prev);\n      if (interval > 0 && interval < x) {\n        this.smallestInterval.x = interval;\n      }\n    };\n    let prevX;\n    if (dataType === \"number\") {\n      for (let i = 0; i < n; i++) {\n        const xDatum = i;\n        const yDatum = data[i];\n        const x = this.getDatum(xDatum, xType);\n        const y = this.getDatum(yDatum, \"number\");\n        if (isContinuousX) {\n          setSmallestXInterval(x, prevX);\n        }\n        xData.push(x);\n        yData.push(y);\n        prevX = x;\n      }\n    } else if (dataType === \"array\") {\n      for (let i = 0; i < n; i++) {\n        const datum = data[i];\n        if (Array.isArray(datum)) {\n          const xDatum = datum[0];\n          const yDatum = datum[1];\n          const x = this.getDatum(xDatum, xType);\n          const y = this.getDatum(yDatum, \"number\");\n          if (x == void 0) {\n            continue;\n          }\n          if (isContinuousX) {\n            setSmallestXInterval(x, prevX);\n          }\n          xData.push(x);\n          yData.push(y);\n          prevX = x;\n        }\n      }\n    } else if (dataType === \"object\") {\n      const { yKey, xKey } = this;\n      for (let i = 0; i < n; i++) {\n        const datum = data[i];\n        if (typeof datum === \"object\" && !Array.isArray(datum)) {\n          const xDatum = datum[xKey];\n          const yDatum = datum[yKey];\n          const x = this.getDatum(xDatum, xType);\n          const y = this.getDatum(yDatum, \"number\");\n          if (x == void 0) {\n            continue;\n          }\n          if (isContinuousX) {\n            setSmallestXInterval(x, prevX);\n          }\n          xData.push(x);\n          yData.push(y);\n          prevX = x;\n        }\n      }\n    }\n    this.updateAxes();\n    this.immediateLayout();\n  }\n  /**\n   * Return the type of data provided to the sparkline based on the first truthy value in the data array.\n   * If the value is not a number, array or object, return `undefined`.\n   * @param data\n   */\n  getDataType(data) {\n    for (const datum of data) {\n      if (datum != void 0) {\n        if (isNumber(datum)) {\n          return \"number\";\n        } else if (Array.isArray(datum)) {\n          return \"array\";\n        } else if (typeof datum === \"object\") {\n          return \"object\";\n        }\n      }\n    }\n  }\n  /**\n   * Return the given value depending on the type of axis.\n   * Return `undefined` if the value is invalid for the given axis type.\n   * @param value\n   */\n  getDatum(value, type) {\n    if (type === \"number\" && isNumber(value) || type === \"time\" && (isNumber(value) || isDate(value))) {\n      return value;\n    } else if (type === \"category\") {\n      if (isString(value) || isDate(value) || isNumber(value)) {\n        return { toString: () => String(value) };\n      } else if (isStringObject(value)) {\n        return value;\n      }\n    }\n  }\n  /**\n   * Only `true` while we are waiting for the layout to start.\n   * This will be `false` if the layout has already started and is ongoing.\n   */\n  get layoutScheduled() {\n    return !!this.layoutId;\n  }\n  /**\n   * Execute update method on the next available screen repaint to make changes to the canvas.\n   * If we are waiting for a layout to start and a new layout is requested,\n   * cancel the previous layout using the non 0 integer (this.layoutId) returned from requestAnimationFrame.\n   */\n  scheduleLayout() {\n    if (this.layoutId) {\n      cancelAnimationFrame(this.layoutId);\n    }\n    this.layoutId = requestAnimationFrame(() => {\n      this.immediateLayout();\n      this.layoutId = 0;\n    });\n  }\n  immediateLayout() {\n    this.setSparklineDimensions();\n    if (this.invalidData(this.data)) {\n      return;\n    }\n    this.updateXScaleRange();\n    this.updateYScaleRange();\n    this.updateAxisLine();\n    this.update();\n    this.renderScene();\n  }\n  setSparklineDimensions() {\n    const { width, height, padding, seriesRect, rootGroup } = this;\n    const shrunkWidth = width - padding.left - padding.right;\n    const shrunkHeight = height - padding.top - padding.bottom;\n    seriesRect.width = shrunkWidth;\n    seriesRect.height = shrunkHeight;\n    seriesRect.x = padding.left;\n    seriesRect.y = padding.top;\n    rootGroup.translationX = seriesRect.x;\n    rootGroup.translationY = seriesRect.y;\n  }\n  /**\n   * Return the closest data point to x/y canvas coordinates.\n   * @param x\n   * @param y\n   */\n  pickClosestSeriesNodeDatum(x, y) {\n    let minDistance = Infinity;\n    let closestDatum;\n    const hitPoint = this.rootGroup.transformPoint(x, y);\n    const nodeData = this.getNodeData();\n    for (let i = 0; i < nodeData.length; i++) {\n      const datum = nodeData[i];\n      if (!datum.point) {\n        return;\n      }\n      const distance = this.getDistance(hitPoint, datum.point);\n      if (distance <= minDistance) {\n        minDistance = distance;\n        closestDatum = datum;\n      }\n    }\n    return closestDatum;\n  }\n  /**\n   * Return the relevant distance between two points.\n   * The distance will be calculated based on the x value of the points for all sparklines except bar sparkline, where the distance is based on the y values.\n   * @param x\n   * @param y\n   */\n  getDistance(p1, p2) {\n    return Math.abs(p1.x - p2.x);\n  }\n  /**\n   * calculate x/y coordinates for tooltip based on coordinates of highlighted datum, position of canvas and page offset.\n   * @param datum\n   */\n  handleTooltip(event, datum) {\n    const { seriesDatum } = datum;\n    const { canvasElement } = this;\n    const { clientX, clientY } = event;\n    const tooltipOptions = this.processedOptions?.tooltip;\n    const meta = {\n      pageX: clientX,\n      pageY: clientY,\n      position: {\n        xOffset: tooltipOptions?.xOffset,\n        yOffset: tooltipOptions?.yOffset\n      },\n      container: tooltipOptions?.container\n    };\n    if (meta.container == void 0) {\n      meta.container = canvasElement;\n    }\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    let enabled = tooltipOptions?.enabled ?? true;\n    const tooltipRenderer = tooltipOptions?.renderer;\n    if (tooltipRenderer) {\n      const tooltipRendererResult = tooltipRenderer({\n        context: this.context,\n        datum: seriesDatum,\n        yValue,\n        xValue\n      });\n      enabled = typeof tooltipRendererResult !== \"string\" && tooltipRendererResult.enabled !== void 0 ? tooltipRendererResult.enabled : enabled;\n    }\n    const html = enabled && seriesDatum.y !== void 0 && this.getTooltipHtml(datum);\n    if (html) {\n      this.tooltip.show(meta, html);\n    }\n  }\n  formatNumericDatum(datum) {\n    return String(Math.round(datum * 10) / 10);\n  }\n  // locale.format('%m/%d/%y, %H:%M:%S');\n  formatDatum(datum) {\n    const type = this.axis.type || \"category\";\n    if (type === \"number\" && typeof datum === \"number\") {\n      return this.formatNumericDatum(datum);\n    } else if (type === \"time\" && (datum instanceof Date || isNumber(datum))) {\n      return this.defaultDateFormatter.format(datum);\n    } else {\n      return String(datum);\n    }\n  }\n  setupDomEventListeners(chartElement) {\n    chartElement.addEventListener(\"mousemove\", this._onMouseMove);\n    chartElement.addEventListener(\"mouseout\", this._onMouseOut);\n  }\n  cleanupDomEventListeners(chartElement) {\n    chartElement.removeEventListener(\"mousemove\", this._onMouseMove);\n    chartElement.removeEventListener(\"mouseout\", this._onMouseOut);\n  }\n  invalidData(data) {\n    return !data || !Array.isArray(data);\n  }\n  /**\n   * Cleanup and remove canvas element from the DOM.\n   */\n  destroy() {\n    this.cleanupDomEventListeners(this.canvasElement);\n    this.scene.destroy();\n    this.container = void 0;\n  }\n};\n_Sparkline.tooltipDocuments = [];\nvar Sparkline = _Sparkline;\n\n// enterprise-modules/sparklines/src/sparkline/tooltip/sparklineTooltip.ts\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return input;\n  }\n  defaults = defaults ?? {};\n  const {\n    content = defaults.content ?? \"\",\n    title = defaults.title ?? void 0,\n    color = defaults.color,\n    backgroundColor = defaults.backgroundColor,\n    opacity = defaults.opacity ?? 1\n  } = input;\n  let titleHtml;\n  let contentHtml;\n  if (color) {\n    titleHtml = title ? `<span class=\"${TooltipClass}-title\"; style=\"color: ${color}\">${title}</span>` : \"\";\n    contentHtml = `<span class=\"${TooltipClass}-content\" style=\"color: ${color}\">${content}</span>`;\n  } else {\n    titleHtml = title ? `<span class=\"${TooltipClass}-title\">${title}</span>` : \"\";\n    contentHtml = `<span class=\"${TooltipClass}-content\">${content}</span>`;\n  }\n  let style = `opacity: ${opacity}`;\n  if (backgroundColor) {\n    style += `; background-color: ${backgroundColor.toLowerCase()}`;\n  }\n  return `<div class=\"${TooltipClass}\" style=\"${style}\">\n                ${titleHtml}\n                ${contentHtml}\n            </div>`;\n}\nvar TooltipClass = \"ag-sparkline-tooltip\";\nvar SparklineTooltip = class {\n  constructor() {\n    this.element = document.createElement(\"div\");\n    const tooltipRoot = document.body;\n    tooltipRoot.appendChild(this.element);\n  }\n  isVisible() {\n    const { element } = this;\n    if (element.classList) {\n      return !element.classList.contains(`${TooltipClass}-wrapper-hidden`);\n    }\n    const classes = element.getAttribute(\"class\");\n    if (classes) {\n      return classes.split(\" \").indexOf(`${TooltipClass}-wrapper-hidden`) < 0;\n    }\n    return false;\n  }\n  updateClass(visible) {\n    const classList = [`${TooltipClass}-wrapper`];\n    if (visible !== true) {\n      classList.push(`${TooltipClass}-wrapper-hidden`);\n    }\n    this.element.setAttribute(\"class\", classList.join(\" \"));\n  }\n  show(meta, html) {\n    this.toggle(false);\n    const { element } = this;\n    if (html !== void 0) {\n      element.innerHTML = html;\n    } else if (!element.innerHTML) {\n      return;\n    }\n    const xOffset = meta.position?.xOffset ?? 10;\n    const yOffset = meta.position?.yOffset ?? 0;\n    let left = meta.pageX + xOffset;\n    let top = meta.pageY + yOffset;\n    const tooltipRect = element.getBoundingClientRect();\n    let maxLeft = window.innerWidth - tooltipRect.width;\n    if (meta.container) {\n      const containerRect = meta.container.getBoundingClientRect();\n      maxLeft = containerRect.left + (containerRect.width - tooltipRect.width);\n    }\n    if (left > maxLeft) {\n      left = meta.pageX - element.clientWidth - xOffset;\n    }\n    if (typeof scrollX !== \"undefined\") {\n      left += scrollX;\n    }\n    if (typeof scrollY !== \"undefined\") {\n      top += scrollY;\n    }\n    element.style.left = `${Math.round(left)}px`;\n    element.style.top = `${Math.round(top)}px`;\n    this.toggle(true);\n  }\n  toggle(visible) {\n    this.updateClass(visible);\n  }\n  destroy() {\n    const { parentNode } = this.element;\n    if (parentNode) {\n      parentNode.removeChild(this.element);\n    }\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/area/areaSparkline.ts\nvar { extent: extent2 } = _Util2;\nvar { BandScale: BandScale2 } = _Scale2;\nvar SparklineMarker = class {\n  constructor() {\n    this.enabled = true;\n    this.shape = \"circle\";\n    this.size = 0;\n    this.fill = \"rgb(124, 181, 236)\";\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n    this.formatter = void 0;\n  }\n};\nvar SparklineLine = class {\n  constructor() {\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n  }\n};\nvar SparklineCrosshairs = class {\n  constructor() {\n    this.xLine = {\n      enabled: true,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n    this.yLine = {\n      enabled: false,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n  }\n};\nvar AreaSparkline = class extends Sparkline {\n  constructor() {\n    super();\n    this.fill = \"rgba(124, 181, 236, 0.25)\";\n    this.strokePath = new _Scene3.Path();\n    this.fillPath = new _Scene3.Path();\n    this.xCrosshairLine = new _Scene3.Line();\n    this.yCrosshairLine = new _Scene3.Line();\n    this.areaSparklineGroup = new _Scene3.Group();\n    this.xAxisLine = new _Scene3.Line();\n    this.markers = new _Scene3.Group();\n    this.markerSelection = _Scene3.Selection.select(\n      this.markers,\n      () => this.markerFactory()\n    );\n    this.markerSelectionData = [];\n    this.marker = new SparklineMarker();\n    this.line = new SparklineLine();\n    this.crosshairs = new SparklineCrosshairs();\n    this.rootGroup.append(this.areaSparklineGroup);\n    this.xAxisLine.zIndex = 500 /* AXIS_LINE_ZINDEX */;\n    this.fillPath.zIndex = 50 /* SERIES_FILL_ZINDEX */;\n    this.strokePath.zIndex = 1e3 /* SERIES_STROKE_ZINDEX */;\n    this.xCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.yCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.markers.zIndex = 2500 /* SERIES_MARKERS_ZINDEX */;\n    this.areaSparklineGroup.append([\n      this.fillPath,\n      this.xAxisLine,\n      this.strokePath,\n      this.xCrosshairLine,\n      this.yCrosshairLine,\n      this.markers\n    ]);\n  }\n  markerFactory() {\n    const { shape } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  getNodeData() {\n    return this.markerSelectionData;\n  }\n  update() {\n    const data = this.generateNodeData();\n    if (!data) {\n      return;\n    }\n    const { nodeData, fillData, strokeData } = data;\n    this.markerSelectionData = nodeData;\n    this.updateSelection(nodeData);\n    this.updateNodes();\n    this.updateStroke(strokeData);\n    this.updateFill(fillData);\n  }\n  updateYScaleDomain() {\n    const { yData, yScale } = this;\n    const yMinMax = extent2(yData);\n    let yMin = 0;\n    let yMax = 1;\n    if (yMinMax !== void 0) {\n      yMin = this.min = yMinMax[0];\n      yMax = this.max = yMinMax[1];\n    }\n    yMin = yMin < 0 ? yMin : 0;\n    yMax = yMax < 0 ? 0 : yMax;\n    yScale.domain = [yMin, yMax];\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale } = this;\n    if (!data) {\n      return;\n    }\n    const continuous = !(xScale instanceof BandScale2);\n    const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n    const n = yData.length;\n    const nodeData = [];\n    const fillData = [];\n    const strokeData = [];\n    let firstValidX;\n    let lastValidX;\n    let previousX;\n    let nextX;\n    const yZero = yScale.convert(0);\n    for (let i = 0; i < n; i++) {\n      const yDatum = yData[i];\n      const xDatum = xData[i];\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n      const y = yDatum === void 0 ? NaN : yScale.convert(yDatum);\n      if (i + 1 < n) {\n        nextX = xScale.convert(continuous ? xScale.toDomain(xData[i + 1]) : xData[i + 1]) + offsetX;\n      }\n      strokeData.push({\n        seriesDatum: { x: xDatum, y: yDatum },\n        point: { x, y }\n      });\n      if (yDatum === void 0 && previousX !== void 0) {\n        fillData.push({ seriesDatum: void 0, point: { x: previousX, y: yZero } });\n        if (nextX !== void 0) {\n          fillData.push({ seriesDatum: void 0, point: { x: nextX, y: yZero } });\n        }\n      } else if (yDatum !== void 0) {\n        fillData.push({\n          seriesDatum: { x: xDatum, y: yDatum },\n          point: { x, y }\n        });\n        nodeData.push({\n          seriesDatum: { x: xDatum, y: yDatum },\n          point: { x, y }\n        });\n        firstValidX = firstValidX !== void 0 ? firstValidX : x;\n        lastValidX = x;\n      }\n      previousX = x;\n    }\n    fillData.push(\n      { seriesDatum: void 0, point: { x: lastValidX, y: yZero } },\n      { seriesDatum: void 0, point: { x: firstValidX, y: yZero } }\n    );\n    return { nodeData, fillData, strokeData };\n  }\n  updateAxisLine() {\n    const { xScale, yScale, axis, xAxisLine } = this;\n    xAxisLine.x1 = xScale.range[0];\n    xAxisLine.x2 = xScale.range[1];\n    xAxisLine.y1 = xAxisLine.y2 = 0;\n    xAxisLine.stroke = axis.stroke;\n    xAxisLine.strokeWidth = axis.strokeWidth;\n    const yZero = yScale.convert(0);\n    xAxisLine.translationY = yZero;\n  }\n  updateSelection(selectionData) {\n    this.markerSelection.update(selectionData);\n  }\n  updateNodes() {\n    const { highlightedDatum, highlightStyle, marker } = this;\n    const {\n      size: highlightSize,\n      fill: highlightFill,\n      stroke: highlightStroke,\n      strokeWidth: highlightStrokeWidth\n    } = highlightStyle;\n    const markerFormatter = marker.formatter;\n    this.markerSelection.each((node, datum, index) => {\n      const { point, seriesDatum } = datum;\n      if (!point) {\n        return;\n      }\n      const highlighted = datum === highlightedDatum;\n      const markerFill = highlighted && highlightFill !== void 0 ? highlightFill : marker.fill;\n      const markerStroke = highlighted && highlightStroke !== void 0 ? highlightStroke : marker.stroke;\n      const markerStrokeWidth = highlighted && highlightStrokeWidth !== void 0 ? highlightStrokeWidth : marker.strokeWidth;\n      const markerSize = highlighted && highlightSize !== void 0 ? highlightSize : marker.size;\n      let markerFormat;\n      if (markerFormatter) {\n        const first = index === 0;\n        const last = index === this.markerSelectionData.length - 1;\n        const min = seriesDatum.y === this.min;\n        const max = seriesDatum.y === this.max;\n        markerFormat = markerFormatter({\n          datum,\n          xValue: seriesDatum.x,\n          yValue: seriesDatum.y,\n          min,\n          max,\n          first,\n          last,\n          fill: markerFill,\n          stroke: markerStroke,\n          strokeWidth: markerStrokeWidth,\n          size: markerSize,\n          highlighted\n        });\n      }\n      node.size = markerFormat && markerFormat.size != void 0 ? markerFormat.size : markerSize;\n      node.fill = markerFormat && markerFormat.fill != void 0 ? markerFormat.fill : markerFill;\n      node.stroke = markerFormat && markerFormat.stroke != void 0 ? markerFormat.stroke : markerStroke;\n      node.strokeWidth = markerFormat && markerFormat.strokeWidth != void 0 ? markerFormat.strokeWidth : markerStrokeWidth;\n      node.translationX = point.x;\n      node.translationY = point.y;\n      node.visible = markerFormat && markerFormat.enabled != void 0 ? markerFormat.enabled : marker.enabled && node.size > 0;\n    });\n  }\n  updateStroke(strokeData) {\n    const { strokePath, yData, line } = this;\n    const path = strokePath.path;\n    path.clear();\n    if (yData.length < 2) {\n      return;\n    }\n    const n = strokeData.length;\n    let moveTo = true;\n    for (let i = 0; i < n; i++) {\n      const { point, seriesDatum } = strokeData[i];\n      const x = point.x;\n      const y = point.y;\n      if (seriesDatum.y == void 0) {\n        moveTo = true;\n      } else {\n        if (moveTo) {\n          path.moveTo(x, y);\n          moveTo = false;\n        } else {\n          path.lineTo(x, y);\n        }\n      }\n    }\n    strokePath.lineJoin = strokePath.lineCap = \"round\";\n    strokePath.fill = void 0;\n    strokePath.stroke = line.stroke;\n    strokePath.strokeWidth = line.strokeWidth;\n  }\n  updateFill(areaData) {\n    const { fillPath, yData, fill } = this;\n    const path = fillPath.path;\n    const n = areaData.length;\n    path.clear();\n    if (yData.length < 2) {\n      return;\n    }\n    for (let i = 0; i < n; i++) {\n      const { point } = areaData[i];\n      const x = point.x;\n      const y = point.y;\n      if (i > 0) {\n        path.lineTo(x, y);\n      } else {\n        path.moveTo(x, y);\n      }\n    }\n    path.closePath();\n    fillPath.lineJoin = \"round\";\n    fillPath.stroke = void 0;\n    fillPath.fill = fill;\n  }\n  updateXCrosshairLine() {\n    const {\n      yScale,\n      xCrosshairLine,\n      highlightedDatum,\n      crosshairs: { xLine }\n    } = this;\n    if (!xLine.enabled || highlightedDatum == void 0) {\n      xCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    xCrosshairLine.y1 = yScale.range[0];\n    xCrosshairLine.y2 = yScale.range[1];\n    xCrosshairLine.x1 = xCrosshairLine.x2 = 0;\n    xCrosshairLine.stroke = xLine.stroke;\n    xCrosshairLine.strokeWidth = xLine.strokeWidth ?? 1;\n    xCrosshairLine.lineCap = xLine.lineCap === \"round\" || xLine.lineCap === \"square\" ? xLine.lineCap : void 0;\n    const { lineDash } = xLine;\n    xCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(xCrosshairLine.lineCap, xLine.lineDash);\n    xCrosshairLine.translationX = highlightedDatum.point.x;\n  }\n  updateYCrosshairLine() {\n    const {\n      xScale,\n      yCrosshairLine,\n      highlightedDatum,\n      crosshairs: { yLine }\n    } = this;\n    if (!yLine.enabled || highlightedDatum == void 0) {\n      yCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    yCrosshairLine.x1 = xScale.range[0];\n    yCrosshairLine.x2 = xScale.range[1];\n    yCrosshairLine.y1 = yCrosshairLine.y2 = 0;\n    yCrosshairLine.stroke = yLine.stroke;\n    yCrosshairLine.strokeWidth = yLine.strokeWidth ?? 1;\n    yCrosshairLine.lineCap = yLine.lineCap === \"round\" || yLine.lineCap === \"square\" ? yLine.lineCap : void 0;\n    const { lineDash } = yLine;\n    yCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(yCrosshairLine.lineCap, yLine.lineDash);\n    yCrosshairLine.translationY = highlightedDatum.point.y;\n  }\n  getTooltipHtml(datum) {\n    const { dataType } = this;\n    const { seriesDatum } = datum;\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    const content = this.formatNumericDatum(yValue);\n    const title = dataType === \"array\" || dataType === \"object\" ? this.formatDatum(xValue) : void 0;\n    const defaults = {\n      content,\n      title\n    };\n    const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n    if (tooltipRenderer) {\n      return toTooltipHtml(\n        tooltipRenderer({\n          context: this.context,\n          datum: seriesDatum,\n          yValue,\n          xValue\n        }),\n        defaults\n      );\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barSparkline.ts\nimport { _Scale as _Scale3, _Scene as _Scene5, _Util as _Util4 } from \"ag-charts-community\";\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barColumnSparkline.ts\nimport { _Scene as _Scene4, _Util as _Util3 } from \"ag-charts-community\";\n\n// enterprise-modules/sparklines/src/sparkline/label/label.ts\nvar Label = class {\n  constructor() {\n    this.enabled = true;\n    this.fontSize = 8;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.color = \"rgba(70, 70, 70, 1)\";\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barColumnSparkline.ts\nvar { extent: extent3 } = _Util3;\nvar BarColumnLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.formatter = void 0;\n    this.placement = \"insideEnd\" /* InsideEnd */;\n  }\n};\nvar BarColumnSparkline = class extends Sparkline {\n  constructor() {\n    super();\n    this.fill = \"rgb(124, 181, 236)\";\n    this.stroke = \"silver\";\n    this.strokeWidth = 0;\n    this.paddingInner = 0.1;\n    this.paddingOuter = 0.2;\n    this.valueAxisDomain = void 0;\n    this.formatter = void 0;\n    this.axisLine = new _Scene4.Line();\n    this.bandWidth = 0;\n    this.sparklineGroup = new _Scene4.Group();\n    this.rectGroup = new _Scene4.Group();\n    this.labelGroup = new _Scene4.Group();\n    this.rectSelection = _Scene4.Selection.select(\n      this.rectGroup,\n      _Scene4.Rect\n    );\n    this.labelSelection = _Scene4.Selection.select(\n      this.labelGroup,\n      _Scene4.Text\n    );\n    this.nodeSelectionData = [];\n    this.label = new BarColumnLabel();\n    this.rootGroup.append(this.sparklineGroup);\n    this.rectGroup.zIndex = 50 /* SERIES_FILL_ZINDEX */;\n    this.axisLine.zIndex = 500 /* AXIS_LINE_ZINDEX */;\n    this.labelGroup.zIndex = 1500 /* SERIES_LABEL_ZINDEX */;\n    this.sparklineGroup.append([this.rectGroup, this.axisLine, this.labelGroup]);\n    this.axisLine.lineCap = \"round\";\n    this.label.enabled = false;\n  }\n  getNodeData() {\n    return this.nodeSelectionData;\n  }\n  update() {\n    this.updateSelections();\n    this.updateNodes();\n  }\n  updateSelections() {\n    const nodeData = this.generateNodeData();\n    if (!nodeData) {\n      return;\n    }\n    this.nodeSelectionData = nodeData;\n    this.updateRectSelection(nodeData);\n    this.updateLabelSelection(nodeData);\n  }\n  updateNodes() {\n    this.updateRectNodes();\n    this.updateLabelNodes();\n  }\n  calculateStep(range) {\n    const { xScale, paddingInner, paddingOuter, smallestInterval } = this;\n    const domainLength = xScale.domain[1] - xScale.domain[0];\n    const intervals = domainLength / (smallestInterval?.x ?? 1) + 1;\n    const maxBands = 50;\n    const bands = Math.min(intervals, maxBands);\n    const gaps = bands - 1;\n    const step = range / Math.max(1, 2 * paddingOuter + gaps * paddingInner + bands);\n    return step;\n  }\n  updateYScaleDomain() {\n    const { yScale, yData, valueAxisDomain } = this;\n    const yMinMax = extent3(yData);\n    let yMin = 0;\n    let yMax = 1;\n    if (yMinMax !== void 0) {\n      yMin = this.min = yMinMax[0];\n      yMax = this.max = yMinMax[1];\n    }\n    yMin = yMin < 0 ? yMin : 0;\n    yMax = yMax < 0 ? 0 : yMax;\n    if (valueAxisDomain) {\n      if (valueAxisDomain[1] < yMax) {\n        valueAxisDomain[1] = yMax;\n      }\n      if (valueAxisDomain[0] > yMin) {\n        valueAxisDomain[0] = yMin;\n      }\n    }\n    yScale.domain = valueAxisDomain ? valueAxisDomain : [yMin, yMax];\n  }\n  updateRectSelection(selectionData) {\n    this.rectSelection.update(selectionData);\n  }\n  updateRectNodes() {\n    const { highlightedDatum, formatter: nodeFormatter, fill, stroke, strokeWidth } = this;\n    const { fill: highlightFill, stroke: highlightStroke, strokeWidth: highlightStrokeWidth } = this.highlightStyle;\n    this.rectSelection.each((node, datum, index) => {\n      const highlighted = datum === highlightedDatum;\n      const nodeFill = highlighted && highlightFill !== void 0 ? highlightFill : fill;\n      const nodeStroke = highlighted && highlightStroke !== void 0 ? highlightStroke : stroke;\n      const nodeStrokeWidth = highlighted && highlightStrokeWidth !== void 0 ? highlightStrokeWidth : strokeWidth;\n      let nodeFormat;\n      const { x, y, width, height, seriesDatum } = datum;\n      if (nodeFormatter) {\n        const first = index === 0;\n        const last = index === this.nodeSelectionData.length - 1;\n        const min = seriesDatum.y === this.min;\n        const max = seriesDatum.y === this.max;\n        nodeFormat = nodeFormatter({\n          datum,\n          xValue: seriesDatum.x,\n          yValue: seriesDatum.y,\n          width,\n          height,\n          min,\n          max,\n          first,\n          last,\n          fill: nodeFill,\n          stroke: nodeStroke,\n          strokeWidth: nodeStrokeWidth,\n          highlighted\n        });\n      }\n      node.fill = nodeFormat && nodeFormat.fill || nodeFill;\n      node.stroke = nodeFormat && nodeFormat.stroke || nodeStroke;\n      node.strokeWidth = nodeFormat && nodeFormat.strokeWidth || nodeStrokeWidth;\n      node.x = node.y = 0;\n      node.width = width;\n      node.height = height;\n      node.visible = node.height > 0;\n      node.translationX = x;\n      node.translationY = y;\n    });\n  }\n  updateLabelSelection(selectionData) {\n    this.labelSelection.update(selectionData, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = _Scene4.PointerEvents.None;\n    });\n  }\n  updateLabelNodes() {\n    const {\n      label: { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color }\n    } = this;\n    this.labelSelection.each((text, datum) => {\n      const label = datum.label;\n      if (label && labelEnabled) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(datum) {\n    const { dataType } = this;\n    const { seriesDatum } = datum;\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    const content = this.formatNumericDatum(yValue);\n    const title = dataType === \"array\" || dataType === \"object\" ? this.formatDatum(xValue) : void 0;\n    const defaults = {\n      content,\n      title\n    };\n    const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n    if (tooltipRenderer) {\n      return toTooltipHtml(\n        tooltipRenderer({\n          context: this.context,\n          datum: seriesDatum,\n          yValue,\n          xValue\n        }),\n        defaults\n      );\n    }\n    return toTooltipHtml(defaults);\n  }\n  formatLabelValue(value) {\n    return value % 1 !== 0 ? value.toFixed(1) : value.toFixed(0);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/barSparkline.ts\nvar { isNumber: isNumber2 } = _Util4;\nvar { BandScale: BandScale3 } = _Scale3;\nvar BarSparkline = class extends BarColumnSparkline {\n  updateYScaleRange() {\n    const { seriesRect, yScale } = this;\n    yScale.range = [0, seriesRect.width];\n  }\n  updateXScaleRange() {\n    const { xScale, seriesRect, paddingOuter, paddingInner } = this;\n    if (xScale instanceof BandScale3) {\n      xScale.range = [0, seriesRect.height];\n      xScale.paddingInner = paddingInner;\n      xScale.paddingOuter = paddingOuter;\n    } else {\n      const step = this.calculateStep(seriesRect.height);\n      const padding = step * paddingOuter;\n      this.bandWidth = step * (1 - paddingInner);\n      xScale.range = [padding, seriesRect.height - padding - this.bandWidth];\n    }\n  }\n  updateAxisLine() {\n    const { yScale, axis, axisLine, seriesRect } = this;\n    const { strokeWidth } = axis;\n    axisLine.x1 = 0;\n    axisLine.x2 = 0;\n    axisLine.y1 = 0;\n    axisLine.y2 = seriesRect.height;\n    axisLine.stroke = axis.stroke;\n    axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);\n    const yZero = yScale.convert(0);\n    axisLine.translationX = yZero;\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;\n    if (!data) {\n      return;\n    }\n    const {\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor,\n      formatter: labelFormatter,\n      placement: labelPlacement\n    } = label;\n    const nodeData = [];\n    const yZero = yScale.convert(0);\n    const continuous = !(xScale instanceof BandScale3);\n    for (let i = 0, n = yData.length; i < n; i++) {\n      let yDatum = yData[i];\n      const xDatum = xData[i];\n      const invalidDatum = yDatum === void 0;\n      if (invalidDatum) {\n        yDatum = 0;\n      }\n      const y = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);\n      const x = Math.min(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const bottom = Math.max(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const height = !continuous ? xScale.bandwidth : this.bandWidth;\n      const width = bottom - x;\n      const midPoint = {\n        x: yZero,\n        y\n      };\n      let labelText;\n      if (labelFormatter) {\n        labelText = labelFormatter({ value: yDatum });\n      } else {\n        labelText = yDatum !== void 0 && isNumber2(yDatum) ? this.formatLabelValue(yDatum) : \"\";\n      }\n      const labelY = y + height / 2;\n      let labelX;\n      const labelTextBaseline = \"middle\";\n      let labelTextAlign;\n      const isPositiveY = yDatum !== void 0 && yDatum >= 0;\n      const labelPadding = 4;\n      if (labelPlacement === \"center\" /* Center */) {\n        labelX = x + width / 2;\n        labelTextAlign = \"center\";\n      } else if (labelPlacement === \"outsideEnd\" /* OutsideEnd */) {\n        labelX = x + (isPositiveY ? width + labelPadding : -labelPadding);\n        labelTextAlign = isPositiveY ? \"start\" : \"end\";\n      } else if (labelPlacement === \"insideEnd\" /* InsideEnd */) {\n        labelX = x + (isPositiveY ? width - labelPadding : labelPadding);\n        labelTextAlign = isPositiveY ? \"end\" : \"start\";\n        const textSize = _Scene5.Text.getTextSize(labelText, labelFontFamily);\n        const textWidth = textSize.width || 20;\n        const positiveBoundary = yZero + textWidth;\n        const negativeBoundary = yZero - textWidth;\n        const exceedsBoundaries = isPositiveY && labelX < positiveBoundary || !isPositiveY && labelX > negativeBoundary;\n        if (exceedsBoundaries) {\n          labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);\n          labelTextAlign = isPositiveY ? \"start\" : \"end\";\n        }\n      } else {\n        labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);\n        labelTextAlign = isPositiveY ? \"start\" : \"end\";\n      }\n      nodeData.push({\n        x,\n        y,\n        width,\n        height,\n        fill,\n        stroke,\n        strokeWidth,\n        seriesDatum: { x: xDatum, y: invalidDatum ? void 0 : yDatum },\n        point: midPoint,\n        label: {\n          x: labelX,\n          y: labelY,\n          text: labelText,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          textAlign: labelTextAlign,\n          textBaseline: labelTextBaseline,\n          fill: labelColor\n        }\n      });\n    }\n    return nodeData;\n  }\n  getDistance(p1, p2) {\n    return Math.abs(p1.y - p2.y);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/bar-column/columnSparkline.ts\nimport { _Scale as _Scale4, _Scene as _Scene6, _Util as _Util5 } from \"ag-charts-community\";\nvar { isNumber: isNumber3 } = _Util5;\nvar { BandScale: BandScale4 } = _Scale4;\nvar ColumnSparkline = class extends BarColumnSparkline {\n  updateYScaleRange() {\n    const { seriesRect, yScale } = this;\n    yScale.range = [seriesRect.height, 0];\n  }\n  updateXScaleRange() {\n    const { xScale, seriesRect, paddingOuter, paddingInner } = this;\n    if (xScale instanceof BandScale4) {\n      xScale.range = [0, seriesRect.width];\n      xScale.paddingInner = paddingInner;\n      xScale.paddingOuter = paddingOuter;\n    } else {\n      const step = this.calculateStep(seriesRect.width);\n      const padding = step * paddingOuter;\n      this.bandWidth = step * (1 - paddingInner);\n      xScale.range = [padding, seriesRect.width - padding - this.bandWidth];\n    }\n  }\n  updateAxisLine() {\n    const { yScale, axis, axisLine, seriesRect } = this;\n    const { strokeWidth } = axis;\n    axisLine.x1 = 0;\n    axisLine.x2 = seriesRect.width;\n    axisLine.y1 = 0;\n    axisLine.y2 = 0;\n    axisLine.stroke = axis.stroke;\n    axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);\n    const yZero = yScale.convert(0);\n    axisLine.translationY = yZero;\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;\n    if (!data) {\n      return;\n    }\n    const {\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor,\n      formatter: labelFormatter,\n      placement: labelPlacement\n    } = label;\n    const nodeData = [];\n    const yZero = yScale.convert(0);\n    const continuous = !(xScale instanceof BandScale4);\n    for (let i = 0, n = yData.length; i < n; i++) {\n      let yDatum = yData[i];\n      const xDatum = xData[i];\n      const invalidDatum = yDatum === void 0;\n      if (invalidDatum) {\n        yDatum = 0;\n      }\n      const y = Math.min(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);\n      const bottom = Math.max(yDatum === void 0 ? NaN : yScale.convert(yDatum), yZero);\n      const width = !continuous ? xScale.bandwidth : this.bandWidth;\n      const height = bottom - y;\n      const midPoint = {\n        x: x + width / 2,\n        y: yZero\n      };\n      let labelText;\n      if (labelFormatter) {\n        labelText = labelFormatter({ value: yDatum });\n      } else {\n        labelText = yDatum !== void 0 && isNumber3(yDatum) ? this.formatLabelValue(yDatum) : \"\";\n      }\n      const labelX = x + width / 2;\n      let labelY;\n      const labelTextAlign = \"center\";\n      let labelTextBaseline;\n      const isPositiveY = yDatum !== void 0 && yDatum >= 0;\n      const labelPadding = 2;\n      if (labelPlacement === \"center\" /* Center */) {\n        labelY = y + height / 2;\n        labelTextBaseline = \"middle\";\n      } else if (labelPlacement === \"outsideEnd\" /* OutsideEnd */) {\n        labelY = y + (isPositiveY ? -labelPadding : height + labelPadding);\n        labelTextBaseline = isPositiveY ? \"bottom\" : \"top\";\n      } else if (labelPlacement === \"insideEnd\" /* InsideEnd */) {\n        labelY = y + (isPositiveY ? labelPadding : height - labelPadding);\n        labelTextBaseline = isPositiveY ? \"top\" : \"bottom\";\n        const textSize = _Scene6.Text.getTextSize(labelText, labelFontFamily);\n        const textHeight = textSize.height || 10;\n        const positiveBoundary = yZero - textHeight;\n        const negativeBoundary = yZero + textHeight;\n        const exceedsBoundaries = isPositiveY && labelY > positiveBoundary || !isPositiveY && labelY < negativeBoundary;\n        if (exceedsBoundaries) {\n          labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);\n          labelTextBaseline = isPositiveY ? \"bottom\" : \"top\";\n        }\n      } else {\n        labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);\n        labelTextBaseline = isPositiveY ? \"bottom\" : \"top\";\n      }\n      nodeData.push({\n        x,\n        y,\n        width,\n        height,\n        fill,\n        stroke,\n        strokeWidth,\n        seriesDatum: { x: xDatum, y: invalidDatum ? void 0 : yDatum },\n        point: midPoint,\n        label: {\n          x: labelX,\n          y: labelY,\n          text: labelText,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          textAlign: labelTextAlign,\n          textBaseline: labelTextBaseline,\n          fill: labelColor\n        }\n      });\n    }\n    return nodeData;\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/line/lineSparkline.ts\nimport { _Scale as _Scale5, _Scene as _Scene7, _Util as _Util6 } from \"ag-charts-community\";\nvar { extent: extent4 } = _Util6;\nvar { BandScale: BandScale5 } = _Scale5;\nvar SparklineMarker2 = class {\n  constructor() {\n    this.enabled = true;\n    this.shape = \"circle\";\n    this.size = 0;\n    this.fill = \"rgb(124, 181, 236)\";\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n    this.formatter = void 0;\n  }\n};\nvar SparklineLine2 = class {\n  constructor() {\n    this.stroke = \"rgb(124, 181, 236)\";\n    this.strokeWidth = 1;\n  }\n};\nvar SparklineCrosshairs2 = class {\n  constructor() {\n    this.xLine = {\n      enabled: true,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n    this.yLine = {\n      enabled: false,\n      stroke: \"rgba(0,0,0, 0.54)\",\n      strokeWidth: 1,\n      lineDash: \"solid\",\n      lineCap: void 0\n    };\n  }\n};\nvar LineSparkline = class extends Sparkline {\n  constructor() {\n    super();\n    this.linePath = new _Scene7.Path();\n    this.xCrosshairLine = new _Scene7.Line();\n    this.yCrosshairLine = new _Scene7.Line();\n    this.lineSparklineGroup = new _Scene7.Group();\n    this.markers = new _Scene7.Group();\n    this.markerSelection = _Scene7.Selection.select(\n      this.markers,\n      () => this.markerFactory()\n    );\n    this.markerSelectionData = [];\n    this.marker = new SparklineMarker2();\n    this.line = new SparklineLine2();\n    this.crosshairs = new SparklineCrosshairs2();\n    this.rootGroup.append(this.lineSparklineGroup);\n    this.linePath.zIndex = 1e3 /* SERIES_STROKE_ZINDEX */;\n    this.xCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.yCrosshairLine.zIndex = 2e3 /* CROSSHAIR_ZINDEX */;\n    this.markers.zIndex = 2500 /* SERIES_MARKERS_ZINDEX */;\n    this.lineSparklineGroup.append([this.linePath, this.xCrosshairLine, this.yCrosshairLine, this.markers]);\n  }\n  getNodeData() {\n    return this.markerSelectionData;\n  }\n  markerFactory() {\n    const { shape } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  /**\n   * If marker shape is changed, this method should be called to remove the previous marker nodes selection.\n   */\n  onMarkerShapeChange() {\n    this.markerSelection = this.markerSelection.clear();\n    this.scheduleLayout();\n  }\n  update() {\n    const nodeData = this.generateNodeData();\n    if (!nodeData) {\n      return;\n    }\n    this.markerSelectionData = nodeData;\n    this.updateSelection(nodeData);\n    this.updateNodes();\n    this.updateLine();\n  }\n  updateYScaleDomain() {\n    const { yData, yScale } = this;\n    const yMinMax = extent4(yData);\n    let yMin = 0;\n    let yMax = 1;\n    if (yMinMax !== void 0) {\n      yMin = this.min = yMinMax[0];\n      yMax = this.max = yMinMax[1];\n    }\n    if (yMin === yMax) {\n      const padding = Math.abs(yMin * 0.01);\n      yMin -= padding;\n      yMax += padding;\n    }\n    yScale.domain = [yMin, yMax];\n  }\n  generateNodeData() {\n    const { data, yData, xData, xScale, yScale } = this;\n    if (!data) {\n      return;\n    }\n    const continuous = !(xScale instanceof BandScale5);\n    const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n    const nodeData = [];\n    for (let i = 0; i < yData.length; i++) {\n      const yDatum = yData[i];\n      const xDatum = xData[i];\n      if (yDatum == void 0) {\n        continue;\n      }\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n      const y = yDatum === void 0 ? NaN : yScale.convert(yDatum);\n      nodeData.push({\n        seriesDatum: { x: xDatum, y: yDatum },\n        point: { x, y }\n      });\n    }\n    return nodeData;\n  }\n  updateSelection(selectionData) {\n    this.markerSelection.update(selectionData);\n  }\n  updateNodes() {\n    const { highlightedDatum, highlightStyle, marker } = this;\n    const {\n      size: highlightSize,\n      fill: highlightFill,\n      stroke: highlightStroke,\n      strokeWidth: highlightStrokeWidth\n    } = highlightStyle;\n    const markerFormatter = marker.formatter;\n    this.markerSelection.each((node, datum, index) => {\n      const highlighted = datum === highlightedDatum;\n      const markerFill = highlighted && highlightFill !== void 0 ? highlightFill : marker.fill;\n      const markerStroke = highlighted && highlightStroke !== void 0 ? highlightStroke : marker.stroke;\n      const markerStrokeWidth = highlighted && highlightStrokeWidth !== void 0 ? highlightStrokeWidth : marker.strokeWidth;\n      const markerSize = highlighted && highlightSize !== void 0 ? highlightSize : marker.size;\n      let markerFormat;\n      const { seriesDatum, point } = datum;\n      if (markerFormatter) {\n        const first = index === 0;\n        const last = index === this.markerSelectionData.length - 1;\n        const min = seriesDatum.y === this.min;\n        const max = seriesDatum.y === this.max;\n        markerFormat = markerFormatter({\n          datum,\n          xValue: seriesDatum.x,\n          yValue: seriesDatum.y,\n          min,\n          max,\n          first,\n          last,\n          fill: markerFill,\n          stroke: markerStroke,\n          strokeWidth: markerStrokeWidth,\n          size: markerSize,\n          highlighted\n        });\n      }\n      node.size = markerFormat && markerFormat.size != void 0 ? markerFormat.size : markerSize;\n      node.fill = markerFormat && markerFormat.fill != void 0 ? markerFormat.fill : markerFill;\n      node.stroke = markerFormat && markerFormat.stroke != void 0 ? markerFormat.stroke : markerStroke;\n      node.strokeWidth = markerFormat && markerFormat.strokeWidth != void 0 ? markerFormat.strokeWidth : markerStrokeWidth;\n      node.translationX = point.x;\n      node.translationY = point.y;\n      node.visible = markerFormat && markerFormat.enabled != void 0 ? markerFormat.enabled : marker.enabled && node.size > 0;\n    });\n  }\n  updateLine() {\n    const { linePath, yData, xData, xScale, yScale, line } = this;\n    const path = linePath.path;\n    path.clear();\n    if (yData.length < 2) {\n      return;\n    }\n    const continuous = !(xScale instanceof BandScale5);\n    const n = yData.length;\n    const offsetX = !continuous ? xScale.bandwidth / 2 : 0;\n    let moveTo = true;\n    for (let i = 0; i < n; i++) {\n      const xDatum = xData[i];\n      const yDatum = yData[i];\n      const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;\n      const y = yDatum === void 0 ? NaN : yScale.convert(yDatum);\n      if (yDatum == void 0) {\n        moveTo = true;\n      } else {\n        if (moveTo) {\n          path.moveTo(x, y);\n          moveTo = false;\n        } else {\n          path.lineTo(x, y);\n        }\n      }\n    }\n    linePath.fill = void 0;\n    linePath.stroke = line.stroke;\n    linePath.strokeWidth = line.strokeWidth;\n  }\n  updateXCrosshairLine() {\n    const {\n      yScale,\n      xCrosshairLine,\n      highlightedDatum,\n      crosshairs: { xLine }\n    } = this;\n    if (!xLine.enabled || highlightedDatum == void 0) {\n      xCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    xCrosshairLine.y1 = yScale.range[0];\n    xCrosshairLine.y2 = yScale.range[1];\n    xCrosshairLine.x1 = xCrosshairLine.x2 = 0;\n    xCrosshairLine.stroke = xLine.stroke;\n    xCrosshairLine.strokeWidth = xLine.strokeWidth ?? 1;\n    xCrosshairLine.lineCap = xLine.lineCap === \"round\" || xLine.lineCap === \"square\" ? xLine.lineCap : void 0;\n    const { lineDash } = xLine;\n    xCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(xCrosshairLine.lineCap, xLine.lineDash);\n    xCrosshairLine.translationX = highlightedDatum.point.x;\n  }\n  updateYCrosshairLine() {\n    const {\n      xScale,\n      yCrosshairLine,\n      highlightedDatum,\n      crosshairs: { yLine }\n    } = this;\n    if (!yLine.enabled || highlightedDatum == void 0) {\n      yCrosshairLine.strokeWidth = 0;\n      return;\n    }\n    yCrosshairLine.x1 = xScale.range[0];\n    yCrosshairLine.x2 = xScale.range[1];\n    yCrosshairLine.y1 = yCrosshairLine.y2 = 0;\n    yCrosshairLine.stroke = yLine.stroke;\n    yCrosshairLine.strokeWidth = yLine.strokeWidth ?? 1;\n    yCrosshairLine.lineCap = yLine.lineCap === \"round\" || yLine.lineCap === \"square\" ? yLine.lineCap : void 0;\n    const { lineDash } = yLine;\n    yCrosshairLine.lineDash = Array.isArray(lineDash) ? lineDash : getLineDash(yCrosshairLine.lineCap, yLine.lineDash);\n    yCrosshairLine.translationY = highlightedDatum.point.y;\n  }\n  getTooltipHtml(datum) {\n    const { dataType } = this;\n    const { seriesDatum } = datum;\n    const yValue = seriesDatum.y;\n    const xValue = seriesDatum.x;\n    const content = this.formatNumericDatum(yValue);\n    const title = dataType === \"array\" || dataType === \"object\" ? this.formatDatum(xValue) : void 0;\n    const defaults = {\n      content,\n      title\n    };\n    const tooltipRenderer = this.processedOptions?.tooltip?.renderer;\n    if (tooltipRenderer) {\n      return toTooltipHtml(\n        tooltipRenderer({\n          context: this.context,\n          datum: seriesDatum,\n          yValue,\n          xValue\n        }),\n        defaults\n      );\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n\n// enterprise-modules/sparklines/src/sparkline/agSparkline.ts\nvar { isNumber: isNumber4 } = _Util7;\nvar AgSparkline = class {\n  static create(options, tooltip) {\n    options = _Util7.deepClone(options);\n    const sparkline = getSparklineInstance(options.type);\n    if (tooltip) {\n      sparkline.tooltip = tooltip;\n    }\n    initSparkline(sparkline, options);\n    initSparklineByType(sparkline, options);\n    if (options.data) {\n      sparkline.data = options.data;\n    }\n    sparkline.processedOptions = options;\n    return sparkline;\n  }\n};\nfunction getSparklineInstance(type = \"line\") {\n  switch (type) {\n    case \"column\":\n      return new ColumnSparkline();\n    case \"bar\":\n      return new BarSparkline();\n    case \"area\":\n      return new AreaSparkline();\n    case \"line\":\n    default:\n      return new LineSparkline();\n  }\n}\nfunction initSparklineByType(sparkline, options) {\n  switch (options.type) {\n    case \"bar\":\n      initBarColumnSparkline(sparkline, options);\n      break;\n    case \"column\":\n      initBarColumnSparkline(sparkline, options);\n      break;\n    case \"area\":\n      initAreaSparkline(sparkline, options);\n      break;\n    case \"line\":\n    default:\n      initLineSparkline(sparkline, options);\n      break;\n  }\n}\nfunction initSparkline(sparkline, options) {\n  setValueIfPropertyExists(sparkline, \"context\", options.context, options);\n  setValueIfPropertyExists(sparkline, \"width\", options.width, options);\n  setValueIfPropertyExists(sparkline, \"height\", options.height, options);\n  setValueIfPropertyExists(sparkline, \"container\", options.container, options);\n  setValueIfPropertyExists(sparkline, \"xKey\", options.xKey, options);\n  setValueIfPropertyExists(sparkline, \"yKey\", options.yKey, options);\n  if (options.padding) {\n    initPaddingOptions(sparkline.padding, options.padding);\n  }\n  if (options.axis) {\n    initAxisOptions(sparkline.axis, options.axis);\n  }\n  if (options.highlightStyle) {\n    initHighlightStyleOptions(sparkline.highlightStyle, options.highlightStyle);\n  }\n}\nfunction initLineSparkline(sparkline, options) {\n  if (options.marker) {\n    initMarkerOptions(sparkline.marker, options.marker);\n  }\n  if (options.line) {\n    initLineOptions(sparkline.line, options.line);\n  }\n  if (options.crosshairs) {\n    initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);\n  }\n}\nfunction initAreaSparkline(sparkline, options) {\n  setValueIfPropertyExists(sparkline, \"fill\", options.fill, options);\n  if (options.marker) {\n    initMarkerOptions(sparkline.marker, options.marker);\n  }\n  if (options.line) {\n    initLineOptions(sparkline.line, options.line);\n  }\n  if (options.crosshairs) {\n    initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);\n  }\n}\nfunction initBarColumnSparkline(sparkline, options) {\n  setValueIfPropertyExists(sparkline, \"valueAxisDomain\", options.valueAxisDomain, options);\n  setValueIfPropertyExists(sparkline, \"fill\", options.fill, options);\n  setValueIfPropertyExists(sparkline, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(sparkline, \"strokeWidth\", options.strokeWidth, options);\n  setValueIfPropertyExists(sparkline, \"paddingInner\", options.paddingInner, options);\n  setValueIfPropertyExists(sparkline, \"paddingOuter\", options.paddingOuter, options);\n  setValueIfPropertyExists(sparkline, \"formatter\", options.formatter, options);\n  if (options.label) {\n    initLabelOptions(sparkline.label, options.label);\n  }\n}\nfunction initPaddingOptions(target, options) {\n  setValueIfPropertyExists(target, \"top\", options.top, options);\n  setValueIfPropertyExists(target, \"right\", options.right, options);\n  setValueIfPropertyExists(target, \"bottom\", options.bottom, options);\n  setValueIfPropertyExists(target, \"left\", options.left, options);\n}\nfunction initMarkerOptions(target, options) {\n  setValueIfPropertyExists(target, \"enabled\", options.enabled, options);\n  setValueIfPropertyExists(target, \"size\", options.size, options);\n  setValueIfPropertyExists(target, \"shape\", options.shape, options);\n  setValueIfPropertyExists(target, \"fill\", options.fill, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n  setValueIfPropertyExists(target, \"formatter\", options.formatter, options);\n}\nfunction initLabelOptions(target, options) {\n  setValueIfPropertyExists(target, \"enabled\", options.enabled, options);\n  setValueIfPropertyExists(target, \"fontStyle\", options.fontStyle, options);\n  setValueIfPropertyExists(target, \"fontWeight\", options.fontWeight, options);\n  setValueIfPropertyExists(target, \"fontSize\", options.fontSize, options);\n  setValueIfPropertyExists(target, \"fontFamily\", options.fontFamily, options);\n  setValueIfPropertyExists(target, \"textAlign\", options.textAlign, options);\n  setValueIfPropertyExists(target, \"textBaseline\", options.textBaseline, options);\n  setValueIfPropertyExists(target, \"color\", options.color, options);\n  setValueIfPropertyExists(target, \"formatter\", options.formatter, options);\n  setValueIfPropertyExists(target, \"placement\", options.placement, options);\n}\nfunction initLineOptions(target, options) {\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n}\nfunction initAxisOptions(target, options) {\n  setValueIfPropertyExists(target, \"type\", options.type, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n}\nfunction initHighlightStyleOptions(target, options) {\n  setValueIfPropertyExists(target, \"fill\", options.fill, options);\n  setValueIfPropertyExists(target, \"size\", options.size, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n}\nfunction initCrosshairsOptions(target, options) {\n  if (target.xLine && options.xLine) {\n    initCrosshairLineOptions(target.xLine, options.xLine);\n  }\n  if (target.yLine && options.yLine) {\n    initCrosshairLineOptions(target.yLine, options.yLine);\n  }\n}\nfunction initCrosshairLineOptions(target, options) {\n  setValueIfPropertyExists(target, \"enabled\", options.enabled, options);\n  setValueIfPropertyExists(target, \"stroke\", options.stroke, options);\n  setValueIfPropertyExists(target, \"strokeWidth\", options.strokeWidth, options);\n  setValueIfPropertyExists(target, \"lineDash\", options.lineDash, options);\n  setValueIfPropertyExists(target, \"lineCap\", options.lineCap, options);\n}\nvar offsetValidator = (property, value, defaultOffset) => {\n  if (isNumber4(value)) {\n    return true;\n  }\n  _warnOnce2(\n    `${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`\n  );\n  return false;\n};\nvar validators = {\n  xOffset: offsetValidator,\n  yOffset: offsetValidator\n};\nfunction setValueIfPropertyExists(target, property, value, options) {\n  if (property in options) {\n    if (property in target) {\n      const validator = validators[property];\n      const isValid = validator ? validator(property, value, target[property]) : true;\n      if (isValid && target[property] !== value) {\n        target[property] = value;\n      }\n    } else {\n      _warnOnce2(`Property ${property} does not exist on the target object.`);\n    }\n  }\n}\n\n// enterprise-modules/sparklines/src/sparklineCellRenderer.ts\nvar SparklineCellRenderer = class extends Component {\n  constructor() {\n    super(\n      /* html */\n      `<div class=\"ag-sparkline-wrapper\">\n            <span data-ref=\"eSparkline\"></span>\n        </div>`\n    );\n    this.eSparkline = RefPlaceholder;\n  }\n  wireBeans(beans) {\n    this.resizeObserverService = beans.resizeObserverService;\n    this.sparklineTooltipSingleton = beans.sparklineTooltipSingleton;\n  }\n  init(params) {\n    let firstTimeIn = true;\n    const updateSparkline = () => {\n      const { clientWidth, clientHeight } = this.getGui();\n      if (clientWidth === 0 || clientHeight === 0) {\n        return;\n      }\n      if (firstTimeIn) {\n        const options = {\n          data: params.value,\n          width: clientWidth,\n          height: clientHeight,\n          context: {\n            data: params.data\n          },\n          ...params.sparklineOptions\n        };\n        this.sparkline = AgSparkline.create(options, this.sparklineTooltipSingleton.getSparklineTooltip());\n        this.eSparkline.appendChild(this.sparkline.canvasElement);\n        firstTimeIn = false;\n      } else {\n        this.sparkline.width = clientWidth;\n        this.sparkline.height = clientHeight;\n      }\n    };\n    const unsubscribeFromResize = this.resizeObserverService.observeResize(this.getGui(), updateSparkline);\n    this.addDestroyFunc(() => unsubscribeFromResize());\n  }\n  refresh(params) {\n    if (this.sparkline) {\n      this.sparkline.data = params.value;\n      return true;\n    }\n    return false;\n  }\n  destroy() {\n    if (this.sparkline) {\n      this.sparkline.destroy();\n    }\n    super.destroy();\n  }\n};\n\n// enterprise-modules/sparklines/src/tooltip/sparklineTooltipSingleton.ts\nimport { BeanStub } from \"@ag-grid-community/core\";\nvar SparklineTooltipSingleton = class extends BeanStub {\n  constructor() {\n    super(...arguments);\n    this.beanName = \"sparklineTooltipSingleton\";\n  }\n  postConstruct() {\n    this.tooltip = new SparklineTooltip();\n  }\n  getSparklineTooltip() {\n    return this.tooltip;\n  }\n  destroy() {\n    if (this.tooltip) {\n      this.tooltip.destroy();\n    }\n    super.destroy();\n  }\n};\n\n// enterprise-modules/sparklines/src/version.ts\nvar VERSION = \"32.0.0\";\n\n// enterprise-modules/sparklines/src/sparklinesModule.ts\nvar SparklinesModule = {\n  version: VERSION,\n  moduleName: ModuleNames.SparklinesModule,\n  beans: [SparklineTooltipSingleton],\n  userComponents: [{ name: \"agSparklineCellRenderer\", classImp: SparklineCellRenderer }],\n  dependantModules: [EnterpriseCoreModule]\n};\nexport {\n  SparklinesModule\n};\n"],
  "mappings": "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",
  "names": ["ModuleNames", "EnterpriseCoreModule", "Component", "RefPlaceholder", "_warnOnce2", "_Util7", "_Scale2", "_Scene3", "_Util2", "_warnOnce", "getLineDash", "lineCap", "lineDash", "buttOrNull", "roundOrSquare", "warnInvalid", "_Scene", "getMarker", "shape", "_errorOnce", "_Scale", "_Scene2", "_Util", "defaultTooltipCss", "extent", "isNumber", "isString", "isStringObject", "isDate", "createId", "Padding", "LinearScale", "BandScale", "TimeScale", "SparklineAxis", "_Sparkline", "root", "element", "scene", "value", "parentNode", "width", "height", "styleElement", "yScale", "seriesRect", "type", "xData", "xScale", "xMinMax", "closestDatum", "event", "e", "oldHighlightedDatum", "data", "yData", "dataType", "xValueType", "xType", "isContinuousX", "setSmallestXInterval", "curr", "prev", "interval", "prevX", "i", "xDatum", "yDatum", "x", "y", "datum", "yKey", "xKey", "padding", "rootGroup", "shrunkWidth", "shrunkHeight", "minDistance", "hitPoint", "nodeData", "distance", "p1", "p2", "seriesDatum", "canvasElement", "clientX", "clientY", "tooltipOptions", "meta", "yValue", "xValue", "enabled", "tooltipRenderer", "tooltipRendererResult", "html", "chartElement", "Sparkline", "toTooltipHtml", "input", "defaults", "content", "title", "color", "backgroundColor", "opacity", "titleHtml", "contentHtml", "TooltipClass", "style", "SparklineTooltip", "classes", "visible", "classList", "xOffset", "yOffset", "left", "top", "tooltipRect", "maxLeft", "containerRect", "extent2", "BandScale2", "SparklineMarker", "SparklineLine", "SparklineCrosshairs", "AreaSparkline", "MarkerShape", "fillData", "strokeData", "yMinMax", "yMin", "yMax", "continuous", "offsetX", "n", "firstValidX", "lastValidX", "previousX", "nextX", "yZero", "axis", "xAxisLine", "selectionData", "highlightedDatum", "highlightStyle", "marker", "highlightSize", "highlightFill", "highlightStroke", "highlightStrokeWidth", "markerFormatter", "node", "index", "point", "highlighted", "markerFill", "markerStroke", "markerStrokeWidth", "markerSize", "markerFormat", "first", "last", "min", "max", "strokePath", "line", "path", "moveTo", "areaData", "fillPath", "fill", "xCrosshairLine", "xLine", "yCrosshairLine", "yLine", "_Scale3", "_Scene5", "_Util4", "_Scene4", "_Util3", "Label", "extent3", "BarColumnLabel", "BarColumnSparkline", "range", "paddingInner", "paddingOuter", "smallestInterval", "intervals", "bands", "gaps", "valueAxisDomain", "nodeFormatter", "stroke", "strokeWidth", "nodeFill", "nodeStroke", "nodeStrokeWidth", "nodeFormat", "text", "labelEnabled", "fontStyle", "fontWeight", "fontSize", "fontFamily", "label", "isNumber2", "BandScale3", "BarSparkline", "step", "axisLine", "labelFontStyle", "labelFontWeight", "labelFontSize", "labelFontFamily", "labelColor", "labelFormatter", "labelPlacement", "invalidDatum", "bottom", "midPoint", "labelText", "labelY", "labelX", "labelTextBaseline", "labelTextAlign", "isPositiveY", "labelPadding", "textWidth", "positiveBoundary", "negativeBoundary", "_Scale4", "_Scene6", "_Util5", "isNumber3", "BandScale4", "ColumnSparkline", "textHeight", "_Scale5", "_Scene7", "_Util6", "extent4", "BandScale5", "SparklineMarker2", "SparklineLine2", "SparklineCrosshairs2", "LineSparkline", "linePath", "isNumber4", "AgSparkline", "options", "tooltip", "sparkline", "getSparklineInstance", "initSparkline", "initSparklineByType", "initBarColumnSparkline", "initAreaSparkline", "initLineSparkline", "setValueIfPropertyExists", "initPaddingOptions", "initAxisOptions", "initHighlightStyleOptions", "initMarkerOptions", "initLineOptions", "initCrosshairsOptions", "initLabelOptions", "target", "initCrosshairLineOptions", "offsetValidator", "property", "defaultOffset", "validators", "validator", "SparklineCellRenderer", "beans", "params", "firstTimeIn", "updateSparkline", "clientWidth", "clientHeight", "unsubscribeFromResize", "BeanStub", "SparklineTooltipSingleton", "VERSION", "SparklinesModule"]
}
